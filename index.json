[{"content":"一，桌面软件   镜像刻录 BalenaEtcher\n  浏览器\n  Google chrome\n  Microsoft Edge\n    输入法 百度输入法\n  安全 火绒\n  通讯\n  QQ\n  WeChat\n    科学上网 Clash,说明文档 介绍\n  音乐\n QQ音乐 网易云音乐    写作\n typroa   Obsidian    压缩 bindzip(6.x免费版本)\n  字体渲染 MacType\n  字体更换 noMeiryoUI\n  下载\n Internet Download Manager(付费软件)   迅雷    时钟屏保 fliqlo\n  图片查看 ImageGlass\n  Microsoft office部署 Office Tool Plus\n  虚拟机 VMware Workstation\n  远程控制 ToDesk\n  图床 PicGo\n  桌面小工具 uTools\n  游戏\n WeGame 暴雪战网 Steam    windows 10美化\n  Rainmeter\n  MyDockFinder\n  wallpaper Engine(付费壁纸软件)\n    Windows 实用工具 Dism++\n  视频播放 Potplayer\n  卸载软件 Geek Uninstaller\n  状态栏透明 TaskbarTools\n  罗技驱动\n Logitech游戏软件(旧版) Logitech G HUB(新版)    全局搜索Everything\n  二，UWP软件   截图 Snipaste\n  视频 Netfix\n  状态栏透明 TranslucentTB\n  磁盘测速 CrystalDiskMark\n  音效 Dolby Access\n  三，实用网站   系统镜像下载\n  下载 Windows 10(官方)\n  MSDN\n    开发者社区CSDN\n  编程技术教程菜鸟教程\n  Web教程MDN\n  黑苹果社区远景论坛\n  矢量图标库阿里巴巴矢量图标库\n  Tampermonkey脚本库Greasy Fork\n  win10美化漫锋网\n  影片下载\n  音范丝\n  布谷TV\n  片源网\n    在线画图\n draw.io   ProcessOn    ","permalink":"https://www.wilds.top/posts/2adeb7d8/","summary":"一，桌面软件   镜像刻录 BalenaEtcher\n  浏览器\n  Google chrome\n  Microsoft Edge\n    输入法 百度输入法\n  安全 火绒\n  通讯\n  QQ\n  WeChat\n    科学上网 Clash,说明文档 介绍\n  音乐\n QQ音乐 网易云音乐    写作\n typroa   Obsidian    压缩 bindzip(6.x免费版本)\n  字体渲染 MacType\n  字体更换 noMeiryoUI","title":"Windows 10自用应用集合"},{"content":"【 ArrayList集合 】 关于集合的常见面试题及源码分析 1. 什么是集合?  集合：集合是java中提供的一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。大致可以分为Set、List、Queue和Map四种体系，其中Set代表无序、不可重复的集合；List代表有序、可重复的集合；而Map则代表具有映射关系的集合，Java 5 又增加了Queue体系集合，代表一种队列集合实现。  2. 集合类之间的继承关系? 集合类主要由两个接口派生而出，分别是单列集合Collection和双列集合Map，它们是Java集合框架的根接口。\n Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是List和Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有ArrayList和LinkedList，Set接口的主要实现类有HashSet和TreeSet。  从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于系统地学习，接下来通过一张图来描述集合类的继承体系。\n图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。\nMap实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的。\n图中，HashMap，TreeMap是我们经常会用到的集合类。\n3. 集合和数组的区别? ​\t1:长度区别 ​ 数组固定 ​ 集合可变 ​ 2:内容区别 ​ 数组可以是基本类型，也可以是引用类型 ​ 集合只能是引用类型 ​ 3:类型区别 ​ 数组只能存储同一种类型 ​ 集合可以存储不同类型\n如果存储的数据长度经常发生改变，推荐使用集合\n4. ArrayList扩容原理？ 4.1.步骤 ​ 1、扩容\n​ 把原来的数组复制到另一个内存空间更大的数组中\n​ 2、添加元素\n​ 把新元素添加到扩容以后的数组中\n4.2.源码(JKD1.8) 先把ArrayList中定义的一些属性粘出来方便下面源码分析\njava\npublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { /** * 默认初始容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** *空数组实例，用于默认大小的空实例 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** *如果新建ArrayList对象时没有指定大小，那么会将 *DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋值给elementData， *并在第一次添加元素时，将列表容量设置为DEFAULT_CAPACITY */ transient Object[] elementData; /** * 列表大小，elementData中存储的元素个数 */ private int size; } 补充：\n通过上述继承关系我们发现一个很奇怪的现象，就是 ArrayList已经继承了AbstractList而 AbstractList类实现了List接口，那为什么 ArrayList还要在实现 List接口呢？同样在 HashMap中 LinkedList 中都是这种结构。\n据 Java 集合框架的创始人 Josh Bloch 描述，这样的写法是一个失误。在 Java 集合框架中，类似这样的写法很多，最开始写 Java 集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然，jdk 的维护者，后来不认为这个小小的失误值得去修改，所以就这样保留下来了。\ntransient ? ? ? 为 Java 关键字，为变量修饰符，如果用 transient 声明一个实例变量，当对象存储时，它的值不需要维持。\n首先介绍一下序列化Serializable\n通常一个类实现序列化方式是实现序列化接口： class XXX implements Serializable\n序列化的作用：把数据长久的保存在磁盘中，磁盘和内存是不同的，内存一般在程序运行时占用，数据保存周期短，随程序结束而结束，磁盘可以长久保存数据\ntransient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，就这个作用\u0026mdash;\u0026mdash;在已序列化的类中使变量不序列化\n这里 Object[] elementData，就是我们的 ArrayList 容器，下面介绍的基本操作都是基于该 elementData 变量来进行操作的。\n接下来看一下ArrayList的两个常用构造方法：\njava\n//带初始容量参数的构造函数。（用户自己指定容量） public ArrayList(int initialCapacity) { if (initialCapacity \u0026gt; 0) {//初始容量大于0  //创建initialCapacity大小的数组  this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) {//初始容量等于0  //创建空数组  this.elementData = EMPTY_ELEMENTDATA; } else {//初始容量小于0，抛出异常  throw new IllegalArgumentException(\u0026#34;Illegal Capacity: \u0026#34;+ initialCapacity); } } //默认构造函数，构造一个空列表(无参数构造) public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 在无参构造中来创建对象的时候,其实就是创建了一个空数组，集合长度为0,没有分配容量,当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。之后扩容会按照1.5倍增长。\n在有参构造中，传入的参数是正整数就按照传入的参数来确定创建数组的大小，否则异常。\n接下来重点，看扩容，扩容的方法就是 add(E e)\npublic boolean add(E e) { ensureCapacityInternal(size + 1); // list的size+1 \telementData[size++] = e; // 将数据放到数组最后一个 \treturn true; } 通过源码可以发现，其实add方法就两步，第一步：增加长度，第二步：添加元素到数组，第二步没什么说的，我们看看ensureCapacityInternal(int minCapacity)这个增加长度的方法。\n这个地方可以看到，如果在添加的时候数组是空的，就直接给一个默认10的长度，否则的话就加1\nif (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); 通过上图这个判断才是真正的增加长度，当需要的长度大于原来数组长度的时候就需要扩容了，相反的则不需要扩容。\ngrow（）方法\njava\n//要分配的最大数组大小 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { // oldCapacity为旧容量，newCapacity为新容量  int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2(如果oldCapacity是奇数,先减1再除以2)  int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量  if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE  if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } 我们来仔细分析一下：\n 当我们要 add 第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为10。此时，minCapacity - elementData.length \u0026gt; 0 成立，所以会进入 grow(minCapacity) 方法。 当add第2个元素时，minCapacity 为2，此时elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length \u0026gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。  　直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。\n​\t再次添加第23个元素，minCapacity(为23)比elementData.length（为10）要大。进入grow方法进行扩容。\n​\t\u0026hellip;\u0026hellip;\n以上的一切都是ArrayList扩容的第一步，第二步就没啥说的了，就是把需要添加的元素添加到数组的最后一位。\n总结：在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组，旧的数组就会使用Arrays.copyOf()方法被复制到新的数组中去，现有的数组引用指向了新的数组。 小疑问 ? ? 为什么每次扩容处理会是 1.5 倍，而不是 2.5、3、4 倍呢？源代码定义1.5倍,是经过了大量的实验，发现 1.5 倍的扩容是最好的倍数。因为一次性扩容太大(例如 2.5 倍)可能会浪费更多的内存(1.5 倍最多浪费 33%，而 2.5 被最多会浪费 60%，3.5 倍则会浪费 71%……)。但是一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以 1.5 倍刚刚好，既能满足性能需求，也不会造成很大的内存消耗。 5. 什么是线程不安全和线程安全？ ​\t线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。\n6. 为什么说ArrayList是线程不安全的？ 6.1 代码复现 java\nprivate static List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); private static ExecutorService executorService = Executors.newFixedThreadPool(500); //定长线程池500  private static class IncreaseTask extends Thread{ @Override public void run() { System.out.println(\u0026#34;ThreadId:\u0026#34; + Thread.currentThread().getId() + \u0026#34; start!\u0026#34;); for(int i =0; i \u0026lt; 100; i++){ list.add(i); } System.out.println(\u0026#34;ThreadId:\u0026#34; + Thread.currentThread().getId() + \u0026#34; finished!\u0026#34;); } } public static void main(String[] args){ //返回当前时间  long start = System.currentTimeMillis(); for(int i=0; i \u0026lt; 500; i++){ //开启500个线程  executorService.submit(new IncreaseTask()); } //停止接收新任务，原来的任务继续执行  executorService.shutdown(); while (!executorService.isTerminated()){//所有提交的任务没完成  try { Thread.sleep(500*10); }catch (InterruptedException e){ e.printStackTrace(); } } System.out.println(\u0026#34;list 长度为: \u0026#34; + list.size()); long end = System.currentTimeMillis(); System.out.println(\u0026#34;用时:\u0026#34;+(double)(end-start)/1000+\u0026#34;秒\u0026#34;); } 打印结果应为：50000，实际测试部分结果如下：\nlist 长度为: 49927\nlist 长度为: 49901\n由此可见是ArrayList做add操作时候，会丢失一些数据，所以所ArrayList是线程不安全的。\n6.2 源码分析(JKD1.8) java\n// Object[] elementData:ArrayList的数据结构是数组类型，list存放的数据就是存放在elementData里面的 // 第1步 public boolean add(E e) { ensureCapacityInternal(size + 1); // list的size+1 \telementData[size++] = e; // 将数据放到数组最后一个 \treturn true; } // 第2步，判断如果将当前的新元素加到列表后面，列表的elementData数组的大小是否满足， // 如果size + 1的这个需求长度大于了elementData这个数组的长度，那么就要对这个数组进行扩容 private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } // 进入ensureExplicitCapacity方法 \tensureExplicitCapacity(minCapacity); } // 第3步，元素有变化，那么就调用grow方法 private void ensureExplicitCapacity(int minCapacity) { modCount++; // elementData：list的数组元素 \t// minCapacity: add操作后的容量 \tif (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } // 第4步 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 为什么要-8，是因为有些虚拟机有一些hear的key private void grow(int minCapacity) { // 原始list的容量（容量不是list.size） \tint oldCapacity = elementData.length; //现在list的容量，此时是做讲原始容量扩大0.5倍，oldCapacity \u0026gt;\u0026gt; 1：2进制右位移，就是除以2的意思 \tint newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; // 一般不会进入hugeCapacity这个方法， \tif (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // 复制elementData返回一个新的数组对象，这个时候list.add完成 \telementData = Arrays.copyOf(elementData, newCapacity); } 由此看到List集合做add（）时，第1步到第3步，都不会改变elementData对象，只有在第4步Arrays.copyOf的时候，返回一个新的数组对象。 因此：当有线程A、B同时进入grow方法，两个线程都会执行Arrays.copyOf()方法，返回2个不同的elementData对象， 假如，A先返回，B后返回，那么List.elementData == A.elementData， 然后B也返回后，这时List.elementData == B.elementData 这时，B.elementData就把A.elementData数据给覆盖了。导致A.elementData被丢失\n这样就出现了导致线程不安全的隐患，在多个线程进行add操作时可能会抛出并发读写异常和数据丢失，覆盖等问题。\n7. 如何避免ArrayList的并发问题? 1.使用Collections.synchronizedList()方法对ArrayList对象进行包装 ArrayList\u0026lt;Integer\u0026gt; arraylist = Collections.synchronizedList(new ArrayList()); 进行测试，结果正确，没有发现数据丢失问题。\n为什么synchronizedList（）方法可以解决并发问题？直接上源码(JKD1.8)\njava\npublic static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; synchronizedList(List\u0026lt;T\u0026gt; list) { return (list instanceof RandomAccess ? new SynchronizedRandomAccessList\u0026lt;\u0026gt;(list) : new SynchronizedList\u0026lt;\u0026gt;(list)); } SynchronizedList(List\u0026lt;E\u0026gt; list) { super(list); this.list = list; } SynchronizedList(List\u0026lt;E\u0026gt; list, Object mutex) { super(list, mutex); this.list = list; } public boolean equals(Object o) { synchronized(mutex) {return list.equals(o);} } public int hashCode() { synchronized(mutex) {return list.hashCode();} } public E get(int index) { synchronized(mutex) {return list.get(index);} } public E set(int index, E element) { synchronized(mutex) {return list.set(index, element);} } public void add(int index, E element) { synchronized(mutex) {list.add(index, element);} } public E remove(int index) { synchronized(mutex) {return list.remove(index);} } public int indexOf(Object o) { synchronized(mutex) {return list.indexOf(o);} } public int lastIndexOf(Object o) { synchronized(mutex) {return list.lastIndexOf(o);} } public boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) { synchronized(mutex) {return list.addAll(index, c);} } public ListIterator\u0026lt;E\u0026gt; listIterator() { return list.listIterator(); // Must be manually synched by user  } public ListIterator\u0026lt;E\u0026gt; listIterator(int index) { return list.listIterator(index); // Must be manually synched by user  } public List\u0026lt;E\u0026gt; subList(int fromIndex, int toIndex) { synchronized(mutex) { return new SynchronizedList\u0026lt;E\u0026gt;(list.subList(fromIndex, toIndex), mutex); } } 关于mutex的定义：\nfinal Collection\u0026lt;E\u0026gt; c; // Backing Collection final Object mutex; // Object on which to synchronize  SynchronizedCollection(Collection\u0026lt;E\u0026gt; c) { if (c==null) throw new NullPointerException(); this.c = c; mutex = this; } SynchronizedCollection(Collection\u0026lt;E\u0026gt; c, Object mutex) { this.c = c; this.mutex = mutex; } 从源码中我们可以看到SynchronizedList是通过对mutex做同步来控制线程安全的，而mutex定义在其父类SynchronizedCollection中。mutex指向的就是当前对象自己，所以SynchronizedList是线程安全的根本原因是使用Synchronized对SynchronizedList的add,delete等操作进行加锁，但是这种锁的力度很大，效率比较低。\n2.使用并发容器CopyOnWriteArrayList CopyOnWriteArrayListlist = new CopyOnWriteArrayList(); 源码(JKD1.8)：\nprivate static final long serialVersionUID = 8673264195747942595L; transient final ReentrantLock lock = new ReentrantLock(); private volatile transient Object[] array; final Object[] getArray() { return array; } final void setArray(Object[] a) { array = a; } public boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } } 从add方法知道：CopyOnWriteArrayList底层数组的扩容方式是一个一个地增加，而且每次把原来的元素通过Arrays.copy()方法copy到新数组中，然后在尾部加上新元素e.它的底层并发安全的保证是通过ReentrantLock进行保证的，CopyOnWriteArrayList和SynchronizedList的底层实现方式是不一样的，前者是通过Lock机制进行加锁，而后者是通过Synchronized进行加锁。\n","permalink":"https://www.wilds.top/posts/ad0a121e/","summary":"【 ArrayList集合 】 关于集合的常见面试题及源码分析 1. 什么是集合?  集合：集合是java中提供的一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。大致可以分为Set、List、Queue和Map四种体系，其中Set代表无序、不可重复的集合；List代表有序、可重复的集合；而Map则代表具有映射关系的集合，Java 5 又增加了Queue体系集合，代表一种队列集合实现。  2. 集合类之间的继承关系? 集合类主要由两个接口派生而出，分别是单列集合Collection和双列集合Map，它们是Java集合框架的根接口。\n Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是List和Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有ArrayList和LinkedList，Set接口的主要实现类有HashSet和TreeSet。  从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于系统地学习，接下来通过一张图来描述集合类的继承体系。\n图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。\nMap实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的。\n图中，HashMap，TreeMap是我们经常会用到的集合类。\n3. 集合和数组的区别? ​\t1:长度区别 ​ 数组固定 ​ 集合可变 ​ 2:内容区别 ​ 数组可以是基本类型，也可以是引用类型 ​ 集合只能是引用类型 ​ 3:类型区别 ​ 数组只能存储同一种类型 ​ 集合可以存储不同类型\n如果存储的数据长度经常发生改变，推荐使用集合\n4. ArrayList扩容原理？ 4.1.步骤 ​ 1、扩容\n​ 把原来的数组复制到另一个内存空间更大的数组中\n​ 2、添加元素\n​ 把新元素添加到扩容以后的数组中\n4.2.源码(JKD1.8) 先把ArrayList中定义的一些属性粘出来方便下面源码分析\njava\npublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { /** * 默认初始容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** *空数组实例，用于默认大小的空实例 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** *如果新建ArrayList对象时没有指定大小，那么会将 *DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋值给elementData， *并在第一次添加元素时，将列表容量设置为DEFAULT_CAPACITY */ transient Object[] elementData; /** * 列表大小，elementData中存储的元素个数 */ private int size; } 补充：","title":"ArrayList经典面试题"},{"content":"一、HashMap 集合简介   HashMap 基于 哈希表 (是根据关键码值(Key value)而直接进行访问的数据结构) 的 Map 接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null，此外，HashMap 中的映射不是有序的。\n  jdk1.8 之前 HashMap 由 数组 + 链表 组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突（两个对象调用的 hashCode 方法计算的哈希值一致导致计算的教组索引值相同）而存在的（“拉链法”解决冲突）。jdk1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。\n  补充：将链表转换成红黑树前会判断，即便阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树，而是选择逬行数组扩容。\n这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层阈值大于8并且数组长度大于64时，链表才转换为红黑树，具体可以参考 treeifyBin() 方法。\n当然,虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。\n  小结：\nHashMap 特点：\n 存储无序的。 键和值位置都可以是 null，但是键位置只能存在一个 null。 键位置是唯一的，是底层的数据结构控制的。 jdk1.8 前数据结构是链表+数组，jdk1.8 之后是链表+数组+红黑树。 阈值（边界值）\u0026gt; 8 并且数组长度大于 64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。    二、HashMap 集合底层的数据结构 2.1数据结构概念 数据结构是[计算机]存储、组织[数据]的方式。数据结构是指相互之间存在一种或多种特定关系的[数据元素]的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储[效率]。数据结构往往同高效的检索[算法]和[索引]技术有关。\n数据结构:就是存储数据的一种方式;\n2.2 存储数据的过程 示例代码：\nHashMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;柳岩\u0026#34;, 18); map.put(\u0026#34;杨幂\u0026#34;, 28); map.put(\u0026#34;刘德华\u0026#34;, 40); map.put(\u0026#34;柳岩\u0026#34;, 20); 输出结果：\n{杨幂=28, 柳岩=20, 刘德华=40} 分析：\n  当创建 HashMap 集合对象的时候，在 jdk1.8 之前，构造方法中创建一个长度是16的 Entry[] table 用来存储键值对数据的。在 jdk1.8 以后不是在 HashMap 的构造方法底层创建数组了，是在第一次调用 put 方法时创建的数组 Node[] table 用来存储键值对数据。\n  假设向哈希表中存储 \u0026lt;柳岩,18\u0026gt; 数据，根据柳岩调用 String 类中重写之后的 hashCode() 方法计算出值，然后结合数组长度采用某种算法计算出向 Node 数组中存储数据的空间的索引值。如果计算出的索引空间没有数据，则直接将\u0026lt;柳岩,18\u0026gt;存储到数组中。（举例：计算出的索引是 3 ）\n  向哈希表中存储数据 \u0026lt;刘德华,40\u0026gt;，假设算出的 hashCode() 方法结合数组长度计算出的索引值也是3，那么此时数组空间不是 null，此时底层会比较柳岩和刘德华的 hash 值是否一致，如果不一致，则在空间上划出一个结点来存储键值对数据对 \u0026lt;刘德华,40\u0026gt;，这种方式称为拉链法。\n  假设向哈希表中存储数据 \u0026lt;柳岩,20\u0026gt;，那么首先根据柳岩调用 hashCode() 方法结合数组长度计算出索引是 3，此时比较后存储的数据柳岩和已经存在的数据的 hash 值是否相等，如果 hash 值相等，此时发生哈希碰撞。那么底层会调用柳岩所属类 String 中的 equals() 方法比较两个key的内容是否相等：\n相等：将后添加的数据的 value 覆盖之前的 value。\n不相等：继续向下和其他的数据的 key 进行比较，如果都不相等，则划出一个结点存储数据，如果结点长度即链表长度大于阈值 8 并且数组长度大于 64 则将链表变为红黑树。   在不断的添加数据的过程中，会涉及到扩容问题，当超出阈值（且要存放的位置非空）时，扩容。默认的扩容方式：扩容为原来容量的 2 倍，并将原有的数据复制过来。\n  综上描述，当位于一个表中的元素较多，即 hash 值相等但是内容不相等的元素较多时，通过 key 值依次查找的效率较低。而 jdk1.8 中，哈希表存储采用数组+链表+红黑树实现，当链表长度（阈值）超过8且当前数组的长度大于64时，将链表转换为红黑树，这样大大减少了查找时间。\n简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示：   jdk1.8 中引入红黑树的进一步原因：\njdk1.8以前 HashMap 的实现是数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当HashMap中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有n个元素，遍历的时间复杂度就是O(n)，完全失去了它的优势。\n针对这种情况，jdk1.8中引入了红黑树（查找时间复杂度为O(logn)）来优化这个问题。当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。\n关于时间复杂度O(n),O(logn)简介,参考:https://www.jianshu.com/p/f31744e423eb\n  总结：\n  说明：\n size 表示 HashMap 中键值对的实时数量，注意这个不等于数组的长度。 threshold（临界值）= capacity（容量）* loadFactor（负载因子）。这个值是当前已占用数组长度的最大值。size超过这个值就重新 resize（扩容），扩容后的 HashMap 容量是之前容量的两倍。  2.3 面试题  HashMap 中 hash 函数是怎么实现的？还有哪些hash函数的实现方式？ 答：对于 key 的 hashCode 做 hash 操作，无符号右移 16 位然后做异或运算。还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移 16 位异或运算效率是最高的。 什么是哈希碰撞，如何解决哈希碰撞？ 答：只要两个元素的 key 计算的哈希码值相同就会发生哈希碰撞。jdk8 之前使用链表解决哈希碰撞。jdk8之后使用链表 + 红黑树解决哈希碰撞。 如果两个键的 hashCode 相同，如何存储键值对？ 答：通过 equals 比较内容是否相同。相同：则新的 value 覆盖之前的 value。不相同：则将新的键值对添加到到链表后面，链表长度超过阈值 8 且数组长度超过64就转换为红黑树存储。  三、HashMap继承关系 HashMap继承关系如下图所示：\n说明：\n Cloneable 空接口，表示可以克隆。创建并返回 HashMap 对象的一个副本。 Serializable 序列化接口。属于标记性接口。HashMap 对象可以被序列化和反序列化。 AbstractMap 父类提供了 Map 实现接口。以最大限度地减少实现此接口所需的工作。  补充：\n通过上述继承关系我们发现一个很奇怪的现象，就是 HashMap 已经继承了AbstractMap 而 AbstractMap 类实现了Map 接口，那为什么 HashMap 还要在实现 Map 接口呢？同样在 ArrayList 中 LinkedLis 中都是这种结构。\n据 Java 集合框架的创始人 Josh Bloch 描述，这样的写法是一个失误。在 Java 集合框架中，类似这样的写法很多，最幵始写 Java 集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，jdk 的维护者，后来不认为这个小小的失误值得去修改，所以就这样保留下来了。\n四、HashMap 集合类的成员 4.1 成员变量 4.1.1 serialVersionUID 序列化版本号\nprivate static final long serialVersionUID = 362498820763181265L; 4.1.2 DEFAULT_LOAD_FACTOR 默认的负载因子\n（默认值 0.75）\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; 4.1.3 MAXIMUM_CAPACITY 集合最大容量\nstatic final int MAXIMUM_CAPACITY = 1 \u0026lt;\u0026lt; 30; // 2的30次幂  4.1.4 UNTREEIFY_THRESHOLD 当链表的值小于 6 则会从红黑树转回链表\n// 当桶（bucket）上的结点数小于这个值，树转为链表 static final int UNTREEIFY_THRESHOLD = 6; 4.1.5 MIN_TREEIFY_CAPACITY 当 Map 里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于4*TREEIFY_THRESHOLD(8)\n// 桶中结构转化为红黑树对应的数组长度最小的值 static final int MIN_TREEIFY_CAPACITY = 64; 4.1.6 entrySet 用来存放缓存\n// 存放具体元素的集合 transient Set\u0026lt;Map.Entry\u0026lt;K,V\u0026gt;\u0026gt; entrySet; 4.1.7 size HashMap 中存放元素的个数(重点)\n// 存放元素的个数，注意这个不等于数组的长度  transient int size; size 为 HashMap 中 K-V 的实时数量，不是数组 table 的长度。\n4.1.8 modCount 用来记录 HashMap 的修改次数\n// 每次扩容和更改 map 结构的计数器  transient int modCount; 4.1.9 threshold 临界值\n用来调整大小下一个容量的值计算方式为（容量*负载因子）\n// 临界值 当实际大小（容量*负载因子）超过临界值时，会进行扩容 int threshold; 4.1.10 DEFAULT_INITIAL_CAPACITY 集合的初始化容量（必须是 2 的 n 次幂）\n// 默认的初始容量是16\t1 \u0026lt;\u0026lt; 4 相当于 1*2的4次方 static final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; 问题：初始化容量为什么必须是 2 的 n 次幂？\nHashMap 构造方法还可以指定集合的初始化容量大小：\n// 构造一个带指定初始容量和默认负载因子（0.75)的空 HashMap。 HashMap(int initialCapacity) 因为当向 HashMap 中添加一个元素的时候，需要根据 key 的 hash 值，去确定其在数组中的具体位置。HashMap 为了存取高效，减少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现的关键就在于把数据存到哪个链表中的算法。\n这个算法实际就是取模，hash % length，计算机中直接求余效率不如位移运算。所以源码中做了优化，使用 hash \u0026amp; (length - 1)，而实际上 hash % length 等于 hash \u0026amp; ( length - 1) ,所以前提必须是 length 是 2 的 n 次幂。\n问题又来了：为什么这样就能均匀分布减少碰撞呢?\n举例:\n说明:按位与运算规则:相同的二进制数位上,都是1的时候,结果为1.否则为0;\n例如: 如果数组长度是2的次幂 hash : 3 length数组长度 : 8(是) 3 \u0026amp; (8-1) 00000011 3 00000111 7 ------------ 00000011 3 索引 hash : 2 length数组长度 : 8(是) 2 \u0026amp; (8-1) 00000010 2 00000111 7 ------------ 00000010 2 索引 =============================================================== 例如: 如果数组长度不是2的次幂 hash : 3 length数组长度 : 9(不是) 3 \u0026amp; (9-1) 00000011 3 00001000 8 ------------ 00000000 0 索引 hash : 2 length数组长度 : 9(不是) 2 \u0026amp; (9-1) 00000010 2 00001000 8 ------------ 00000000 0 索引 总结:如果数组长度不是2的次幂,计算出的索引特别容易相同,及其容易发生hash碰撞,导致其余数组空间很大程度上并没有存储数据,链表或者红黑树过长,效率降低.\n问题：如果初始容量不设置2的次幂,比如10呢?\n/** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) {//10  int n = cap - 1; n |= n \u0026gt;\u0026gt;\u0026gt; 1; n |= n \u0026gt;\u0026gt;\u0026gt; 2; n |= n \u0026gt;\u0026gt;\u0026gt; 4; n |= n \u0026gt;\u0026gt;\u0026gt; 8; n |= n \u0026gt;\u0026gt;\u0026gt; 16; return (n \u0026lt; 0) ? 1 : (n \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } | 按位或运算规则: 相同的二进制数位上,都是0的时候,结果为0.否则为1 \u0026gt;\u0026gt;\u0026gt; 无符号右移 说明：\n当在实例化 HashMap 实例时，如果给定了 initialCapacity，由于 HashMap 的 capacity 必须都是 2 的次幂，因此这个方法用于找到大于等于 initialCapacity 的最小的 2 的幂。\n分析：\nint n = cap - 1; 防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂，又没有这个减 1 操作，则执行完后面的几条无符号操作之后，返回的 capacity 将是这个 cap 的 2 倍。\n完整例子：\n注意：得到的这个 capacity(容量) 却被赋值给了 threshold(临界值(容量*负载因子))。\n思考一下: capacity 被赋值给了 threshold这样有没有问题?后面讲解\nthis.threshold = tableSizeFor(initialCapacity); 4.1.11 TREEIFY_THRESHOLD 当链表的值超过8则会转为红黑树（jdk1.8新增）\n// 当桶（bucket）上的结点数大于这个值时会转为红黑树 static final int TREEIFY_THRESHOLD = 8; 问题：为什么 Map 桶中结点个数超过 8 才转为红黑树？\n我们都知道，链表的时间复杂度是O(n)，红黑树的时间复杂度O(logn)，很显然，红黑树的复杂度是优于链表的，既然这么棒，那为什么hashmap为什么不直接就用红黑树呢?请看下图\n在 HashMap 中有一段注释说明：\nBecause TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http://en.wikipedia.org/wiki/Poisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The first values are: 翻译：因为树结点的大小大约是普通结点的两倍，所以我们只在箱子包含足够的结点时才使用树结点(参见TREEIFY_THRESHOLD)。 当它们变得太小（由于删除或调整大小）时，就会被转换回普通的桶。在使用分布良好的用户 hashCode 时，很少使用树箱。 理想情况下，在随机哈希码下，箱子中结点的频率服从泊松分布 (http://en.wikipedia.org/wiki/Poisson_distribution) ，默认调整阈值为0.75，平均参数约为0.5，尽管由 于调整粒度的差异很大。忽略方差，列表大小k的预朗出现次数是(exp(-0.5) * pow(0.5, k) / factorial(k))。 第一个值是： 0: 0.60653066 1: 0.30326533 2: 0.07581633 3: 0.01263606 4: 0.00157952 5: 0.00015795 6: 0.00001316 7: 0.00000094 8: 0.00000006 more: less than 1 in ten million 源码中的注释写的很清楚，因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。\n为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点遵循泊松分布，而且根据统计，链表中节点数是8的概率已经接近千万分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。\n综上所述,我们可以看到，一个 桶 中链表长度达到 8 个元素的槪率为 0.00000006，几乎是不可能事件。所以，之所以选择 8，不是随便決定的，而是裉据概率统计决定的。甶此可见，发展将近30年的 Java 每一项改动和优化都是非常严谨和科学的。\n也就是说：选择 8 因为符合泊松分布，超过 8 的时候，概率已经非常小了，所以我们选择 8 这个数宇。\n  以下是在一些资料上面翻看的解释，供大家参考：\n红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8) = 3，链表的平均查找长度为 n/2，当长度为 8 时，平均查找长虔为 8/2 = 4，这才有转换成树的必要；链表长度如果是小于等于 6， 6/2 = 3，而 log(6) = 2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。\n  4.1.12 table table 用来初始化（必须是2的n次幂）(重点)\n// 存储元素的数组 transient Node\u0026lt;K,V\u0026gt;[] table; 在 jdk1.8 中我们了解到 HashMap 是由数组加链表加红黑树来组成的结构，其中 table 就是 HashMap 中的数组，jdk8 之前数组类型是 Entry\u0026lt;K,V\u0026gt; 类型。从 jdk1.8 之后是 Node\u0026lt;K,V\u0026gt; 类型。只是换了个名字，都实现了一样的接口：Map.Entry\u0026lt;K,V\u0026gt;。负责存储键值对数据的。\n4.1.13 loadFactor 负载因子,哈希表的负载因子(重点)\n// 负载因子 final float loadFactor; 说明：\n loadFactor 是用来衡量 HashMap 满的程度，表示HashMap的疏密程度，影响 hash 操作到同一个数组位置的概率 loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 当 HashMap 里面容纳的元素已经达到 HashMap 数组长度的 75% 时，表示 HashMap 太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。所以开发中尽量减少扩容的次数，可以通过创建 HashMap 集合对象时指定初始容量来尽量避免。 在 HashMap 的构造器中可以定制 loadFactor。  // 构造方法，构造一个带指定初始容量和负载因子的空HashMap HashMap(int initialCapacity, float loadFactor);   为什么负载因子设置为0.75，初始化临界值是12？\nloadFactor 越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，\nloadFactor 越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。\n如果希望链表尽可能少些，要提前扩容。有的数组空间有可能一直没有存储数据，负载因子尽可能小一些。\n  举例：\n例如：负载因子是0.4。 那么16*0.4---\u0026gt;6 如果数组中满6个空间就扩容会造成数组利用率太低了。 负载因子是0.9。 那么16*0.9---\u0026gt;14 那么这样就会导致链表有点多了，导致查找元素效率低。 所以既兼顾数组利用率又考虑链表不要太多，经过大量测试 0.75 是最佳方案。\n  threshold 计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。\n这个值是当前已占用数组长度的最大值。当 Size \u0026gt;= threshold 的时候，那么就要考虑对数组的 resize(扩容)，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。 扩容后的 HashMap 容量是之前容量的两倍。\n  4.2 构造方法 HashMap 中重要的构造方法，它们分别如下：\n4.2.1 HashMap() 构造一个空的HashMap，默认初始容量（16）和默认负载因子（0.75）。\npublic HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // 将默认的负载因子0.75赋值给loadFactor，并没有创建数组 } 4.2.2 HashMap(int initialCapacity) 构造一个具有指定的初始容量和默认负载因子（0.75）HashMap 。\n// 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } 4.2.3 HashMap(int initialCapacity, float loadFactor) 构造一个具有指定的初始容量和负载因子的 HashMap。\n/* 指定“容量大小”和“负载因子”的构造函数 initialCapacity：指定的容量 loadFactor:指定的负载因子 */ public HashMap(int initialCapacity, float loadFactor) { // 判断初始化容量initialCapacity是否小于0  if (initialCapacity \u0026lt; 0) // 如果小于0，则抛出非法的参数异常IllegalArgumentException  throw new IllegalArgumentException(\u0026#34;Illegal initial capacity: \u0026#34; + initialCapacity); // 判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY  if (initialCapacity \u0026gt; MAXIMUM_CAPACITY) // 如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity  initialCapacity = MAXIMUM_CAPACITY; // 判断负载因子loadFactor是否小于等于0或者是否是一个非数值  if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) // 如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException  throw new IllegalArgumentException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); // 将指定的负载因子赋值给HashMap成员变量的负载因子loadFactor  this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } // 最后调用了tableSizeFor，来看一下方法实现：  /* 返回比指定初始化容量大的最小的2的n次幂 */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n \u0026gt;\u0026gt;\u0026gt; 1; n |= n \u0026gt;\u0026gt;\u0026gt; 2; n |= n \u0026gt;\u0026gt;\u0026gt; 4; n |= n \u0026gt;\u0026gt;\u0026gt; 8; n |= n \u0026gt;\u0026gt;\u0026gt; 16; return (n \u0026lt; 0) ? 1 : (n \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 说明：\n对于 javathis.threshold = tableSizeFor(initialCapacity); 疑问解答：\ntableSizeFor(initialCapacity)判断指定的初始化容量是否是2的n次幂，如果不是那么会变为大于等于 initialCapacity 的最小的 2 的幂。 但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug，应该这样书写： this.threshold = tableSizeFor(initialCapacity) * this.loadFactor; 这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。 但是请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算。 4.2.4 HashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) 了解 包含另一个 “Map” 的构造函数\n// 构造一个映射关系与指定 Map 相同的新 HashMap。 public HashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m) { // 负载因子loadFactor变为默认的负载因子0.75  this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } 最后调用了 putMapEntries()，来看一下方法实现：\nfinal void putMapEntries(Map\u0026lt;? extends K, ? extends V\u0026gt; m, boolean evict) { //获取参数集合的长度  int s = m.size(); if (s \u0026gt; 0) { //判断参数集合的长度是否大于0，说明大于0  if (table == null) { // 判断table是否已经初始化  // 未初始化，s为m的实际元素个数  float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft \u0026lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值  if (t \u0026gt; threshold) threshold = tableSizeFor(t); } // 已初始化，并且m元素个数大于阈值，进行扩容处理  else if (s \u0026gt; threshold) resize(); // 将m中的所有元素添加至HashMap中  for (Map.Entry\u0026lt;? extends K, ? extends V\u0026gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } 注意：(了解)\nfloat ft = ((float)s / loadFactor) + 1.0F; 这一行代码中为什么要加 1.0F ？\ns/loadFactor 的结果是小数，加 1.0F 与 (int)ft 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数。所以 + 1.0F 是为了获取更大的容量。\n例如：原来集合的元素个数是 6 个，那么 6/0.75 是8，是 2 的n次幂，那么新的数组大小就是 8 了。然后原来数组的数据就会存储到长度是 8 的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果 +1 呢，数组长度直接变为16了，这样可以减少数组的扩容。\n4.3 成员方法 4.3.1 增加方法 put() (重点) put方法是比较复杂的，实现步骤大致如下：\n  先通过 hash 值计算出 key 映射到哪个桶；\n  如果桶上没有碰撞冲突，则直接插入；\n  如果出现碰撞冲突了，则需要处理冲突：\na 如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；\nb 否则采用传统的链式方法插入。如果链的长度达到阈值，则把链转变为红黑树；\n  如果桶中存在重复的键，则为该键替换新值 value；\n  如果 size 大于临界值 threshold，则进行扩容；\n  具体的方法如下：\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 说明：\n HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。 所以我们重点看 putVal 方法。 我们可以看到在 putVal 方法中 key 在这里执行了一下 hash 方法,来看一下 hash 方法是如何实现的。  static final int hash(Object key) { int h; /* 1）如果key等于null：返回的是0. 2）如果key不等于null：首先计算出key的hashCode赋值给h，然后与h无符号右移16位后的 二进制进行按位异或得到最后的hash值 */ return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 从上面可以得知 HashMap 是支持 key 为空的，而 HashTable 是直接用 Key 来获取hashCode 所以 key 为空会抛异常。\n解读上述 hash 方法：\n我们先研究下 key 的哈希值是如何计算出来的。\n这个哈希方法首先计算出 key 的 hashCode 赋值给 h，然后与 h 无符号右移 16 位后的二进制进行按位异或得到最后的 hash 值。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 在 putVal 函数中使用到了上述 hash 函数计算的哈希值：\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { ... if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) // 这里的n表示数组长度16 \t... } 计算过程如下所示：\n说明：\n key.hashCode()；返回散列值也就是 hashcode，假设随便生成的一个值。 n 表示数组初始化的长度是 16。 \u0026amp;（按位与运算）：运算规则：相同的二进制数位上，都是 1 的时候，结果为 1，否则为0。 ^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为 0，不同为 1。  简单来说就是：\n高 16bit 不变，低 16bit 和高 16bit 做了一个异或（得到的 hashCode 转化为 32 位二进制，前 16 位和后 16 位,低 16bit 和高 16bit 做了一个异或）。\n问题：为什么要这样操作呢？\n如果当 n 即数组长度很小，假设是 16 的话，那么 n - 1 即为 1111(15的二进制表示) ，这样的值和 hashCode 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。\n假设hashCode值直接和数组长度(n-1)按位与运算 1111 1111 1111 1111 1111 0000 1110 1010 h=key.hashCode()，假设随便生成的一个值。 0000 0000 0000 0000 0000 0000 0000 1111 (16 - 1) --------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 1010 10索引 再存储一个key计算出hashCode值:加入高位变化很大,低位没有改变 1001 1001 1001 1111 1111 0000 1110 1010 0000 0000 0000 0000 0000 0000 0000 1111 (16 - 1) --------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 1010 10索引 现在看 putVal 方法，看看它到底做了什么。\n主要参数：\n hash：key 的 hash 值 key：原始 key value：要存放的值 onlyIfAbsent：如果 true 代表不更改现有的值 evict：如果为false表示 table 为创建状态  putVal 方法源代码如下所示：\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; /* 1）transient Node\u0026lt;K,V\u0026gt;[] table; 表示存储Map集合中元素的数组。 2）(tab = table) == null 表示将空的table赋值给tab，然后判断tab是否等于null，第一次肯定是null。 3）(n = tab.length) == 0 表示将数组的长度0赋值给n，然后判断n是否等于0，n等于0，由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化，并将初始化好的数组长度赋值给n。 4）执行完n = (tab = resize()).length，数组tab每个空间都是null。 */ if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /* 1）i = (n - 1) \u0026amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中。 2）p = tab[i = (n - 1) \u0026amp; hash]表示获取计算出的位置的数据赋值给结点p。 3) (p = tab[i = (n - 1) \u0026amp; hash]) == null 判断结点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的结点放入该位置的桶中。 小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置。 */ if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) // 创建一个新的结点存入到桶中  tab[i] = newNode(hash, key, value, null); else { // 执行else说明tab[i]不等于null，表示这个位置已经有值了  Node\u0026lt;K,V\u0026gt; e; K k; /* 比较桶中第一个元素(数组中的结点)的hash值和key是否相等 1）p.hash == hash ：p.hash表示原来存在数据的hash值 hash表示后添加数据的hash值 比较两个hash值是否相等。 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。 Node\u0026lt;K,V\u0026gt; newNode(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { return new Node\u0026lt;\u0026gt;(hash, key, value, next); } 而在Node类中具有成员变量hash用来记录着之前数据的hash值的。 2）(k = p.key) == key ：p.key获取原来数据的key赋值给k key 表示后添加数据的key比较两个key的地址值是否相等。 3）key != null \u0026amp;\u0026amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等。 */ if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) /* 说明：两个元素哈希值相等，并且key的值也相等，将旧的元素整体对象赋值给e，用e来记录 */ e = p; // hash值不相等或者key不相等；判断p是否为红黑树结点  else if (p instanceof TreeNode) // 放入树中  e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); // 说明是链表结点  else { /* 1)如果是链表的话需要遍历到最后结点然后插入 2)采用循环遍历的方式，判断链表中是否有重复的key */ for (int binCount = 0; ; ++binCount) { /* 1)e = p.next 获取p的下一个元素赋值给e。 2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键，将该键值对插入链表中。 */ if ((e = p.next) == null) { /* 1）创建一个新的结点插入到尾部 p.next = newNode(hash, key, value, null); Node\u0026lt;K,V\u0026gt; newNode(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { return new Node\u0026lt;\u0026gt;(hash, key, value, next); } 注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个结点肯定是null。 2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素。 */ p.next = newNode(hash, key, value, null); /* 1)结点添加完成之后判断此时结点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树。 2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历结点的个数。值是0表示第一个结点，1表示第二个结点。。。。7表示第八个结点，加上数组中的的一个元素，元素个数是9。 TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7 如果binCount的值是7(加上数组中的的一个元素，元素个数是9) TREEIFY_THRESHOLD - 1也是7，此时转换红黑树。 */ if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  // 转换为红黑树  treeifyBin(tab, hash); // 跳出循环  break; } /* 执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插入的元素的key值是否相等。 */ if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) // 相等，跳出循环  /* 要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了 直接执行下面的if语句去替换去 if (e != null) */ break; /* 说明新添加的元素和当前结点不相等，继续查找下一个结点。 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 */ p = e; } } /* 表示在桶中找到key值、hash值与插入元素相等的结点 也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值 这里完成了put方法的修改功能 */ if (e != null) { // 记录e的value  V oldValue = e.value; // onlyIfAbsent为false或者旧值为null  if (!onlyIfAbsent || oldValue == null) // 用新值替换旧值  // e.value 表示旧值 value表示新值  e.value = value; // 访问后回调  afterNodeAccess(e); // 返回旧值  return oldValue; } } // 修改记录次数  ++modCount; // 判断实际大小是否大于threshold阈值，如果超过则扩容  if (++size \u0026gt; threshold) resize(); // 插入后回调  afterNodeInsertion(evict); return null; } 4.3.2 将链表转换为红黑树 treeifyBin() (了解) 结点添加完成之后判断此时结点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：\nif (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  //转换为红黑树 tab表示数组名 hash表示哈希值  treeifyBin(tab, hash); treeifyBin 方法如下所示：\n/* 替换指定哈希表的索引处桶中的所有链接结点，除非表太小，否则将修改大小。 Node\u0026lt;K,V\u0026gt;[] tab = tab 数组名 int hash = hash表示哈希值 */ final void treeifyBin(Node\u0026lt;K,V\u0026gt;[] tab, int hash) { int n, index; Node\u0026lt;K,V\u0026gt; e; /* 如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)，就去扩容。而不是将结点变为红黑树。 目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。 */ if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) //扩容方法  resize(); else if ((e = tab[index = (n - 1) \u0026amp; hash]) != null) { /* 1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化 2）e = tab[index = (n - 1) \u0026amp; hash]表示将数组中的元素取出赋值给e，e是哈希表中指定位置桶里的链表结点，从第一个开始 */ // hd：红黑树的头结点 tl：红黑树的尾结点  TreeNode\u0026lt;K,V\u0026gt; hd = null, tl = null; do { // 新创建一个树的结点，内容和当前链表结点e一致  TreeNode\u0026lt;K,V\u0026gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; // 将新创键的p结点赋值给红黑树的头结点  else { p.prev = tl; // 将上一个结点p赋值给现在的p的前一个结点  tl.next = p; // 将现在结点p作为树的尾结点的下一个结点  } tl = p; /* e = e.next 将当前结点的下一个结点赋值给e，如果下一个结点不等于null 则回到上面继续取出链表中结点转换为红黑树 */ } while ((e = e.next) != null); /* 让桶中的第一个元素即数组中的元素指向新建的红黑树的结点，以后这个桶里的元素就是红黑树 而不是链表数据结构了 */ if ((tab[index] = hd) != null) hd.treeify(tab); } } 小结：上述操作一共做了如下几件事：\n 根据哈希表中元素个数确定是扩容还是树形化。 如果是树形化遍历桶中的元素，创建相同个数的树形结点，复制内容，建立起联系。 然后让桶中的第一个元素指向新创建的树根结点，替换桶的链表内容为树形化内容。  4.3.3 扩容方法 resize() (重点) 扩容机制：\n  什么时候才需要扩容\n当 HashMap 中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor 的默认值是 0.75。\n  HashMap 的扩容是什么\n进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。\n设计计算hash值时，要避免出现hash冲突。也就是说不能让它出现链表，更不应该出现红黑树，这样性能很差，如果出现了，证明hash算法，设计的太差。为了避免hash冲突，一，hash算法，二，加载因子。\nHashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n - 1) \u0026amp; hash 的结果相比，只是多了一个 bit 位，所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。\n例如我们从 16 扩展为 32 时，具体的变化如下所示：\n  源数组长度: 16 n = 16 n-1=15 (n-1) \u0026amp; hash 0000 0000 0000 0000 0000 0000 0001 0000 16 0000 0000 0000 0000 0000 0000 0000 1111 15 n-1 假设一个hash1(key1): 1111 1111 1111 1111 0000 1111 0000 0101 ----------------------------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0101 索引 5 0000 0000 0000 0000 0000 0000 0000 1111 15 n-1 假设一个hash2(key2): 1111 1111 1111 1111 0000 1111 0001 0101\t----------------------------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0101 索引 5 ======================================================================================= 此时数组扩容--\u0026gt; 16 * 2 = 32 n = 32 n-1=31 (n-1) \u0026amp; hash 0000 0000 0000 0000 0000 0000 0010 0000 32 0000 0000 0000 0000 0000 0000 0001 1111 31 n-1 假设一个hash1(key1): 1111 1111 1111 1111 0000 1111 0000 0101 ----------------------------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0101 索引 5 0000 0000 0000 0000 0000 0000 0001 1111 31 n-1 假设一个hash2(key2): 1111 1111 1111 1111 0000 1111 0001 0101\t----------------------------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0001 0101 索引 5 + 16 扩容之后的索引位置要么是原来索引,要么是原来索引 + 旧数组容量 举例: 5 或者 5 + 16 因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n - 1 的标记范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化。\n说明：\n5 是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。\n因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了，是 0 的话索引没变，是 1 的话索引变成 “原位置 + 旧容量” 。可以看看下图为 16 扩充为 32 的 resize 示意图：\n正是因为这样巧妙的 rehash 方式，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，在 resize 的过程中保证了 rehash 之后每个桶上的结点数一定小于等于原来桶上的结点数，保证了 rehash 之后不会出现更严重的 hash 冲突，均匀的把之前的冲突的结点分散到新的桶中了。\n源码 resize 方法的解读\n下面是代码的具体实现：\nfinal Node\u0026lt;K,V\u0026gt;[] resize() { // 得到当前数组  Node\u0026lt;K,V\u0026gt;[] oldTab = table; // 如果当前数组等于null长度返回0，否则返回当前数组的长度  int oldCap = (oldTab == null) ? 0 : oldTab.length; //当前阀值点 默认是12(16*0.75)  int oldThr = threshold; int newCap, newThr = 0; // 如果老的数组长度大于0  // 开始计算扩容后的大小  if (oldCap \u0026gt; 0) { // 超过最大值就不再扩充了，就只好随你碰撞去吧  if (oldCap \u0026gt;= MAXIMUM_CAPACITY) { // 修改阈值为int的最大值  threshold = Integer.MAX_VALUE; return oldTab; } /* 没超过最大值，就扩充为原来的2倍 1) (newCap = oldCap \u0026lt;\u0026lt; 1) \u0026lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量 2）oldCap \u0026gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16 */ else if ((newCap = oldCap \u0026lt;\u0026lt; 1) \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; oldCap \u0026gt;= DEFAULT_INITIAL_CAPACITY) // 阈值扩大一倍  newThr = oldThr \u0026lt;\u0026lt; 1; // double threshold  } // 老阈值点大于0 直接赋值  else if (oldThr \u0026gt; 0) // 老阈值赋值给新的数组长度  newCap = oldThr; else { // 直接使用默认值  newCap = DEFAULT_INITIAL_CAPACITY;//16  newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的resize最大上限  if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } // 新的阀值 默认原来是12 乘以2之后变为24  threshold = newThr; // 创建新的哈希表  @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) //newCap是新的数组长度--》32  Node\u0026lt;K,V\u0026gt;[] newTab = (Node\u0026lt;K,V\u0026gt;[])new Node[newCap]; table = newTab; // 判断旧数组是否等于空  if (oldTab != null) { // 把每个bucket都移动到新的buckets中  // 遍历旧的哈希表的每个桶，重新计算桶里元素的新位置  for (int j = 0; j \u0026lt; oldCap; ++j) { Node\u0026lt;K,V\u0026gt; e; if ((e = oldTab[j]) != null) { // 原来的数据赋值为null 便于GC回收  oldTab[j] = null; // 判断数组是否有下一个引用  if (e.next == null) // 没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入  newTab[e.hash \u0026amp; (newCap - 1)] = e; //判断是否是红黑树  else if (e instanceof TreeNode) // 说明是红黑树来处理冲突的，则调用相关方法把树分开  ((TreeNode\u0026lt;K,V\u0026gt;)e).split(this, newTab, j, oldCap); else { // 采用链表处理冲突  Node\u0026lt;K,V\u0026gt; loHead = null, loTail = null; Node\u0026lt;K,V\u0026gt; hiHead = null, hiTail = null; Node\u0026lt;K,V\u0026gt; next; // 通过上述讲解的原理来计算结点的新位置  do { // 原索引  next = e.next; // 这里来判断如果等于true e这个结点在resize之后不需要移动位置  if ((e.hash \u0026amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引+oldCap  else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里  if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket里  if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 4.3.5 查找元素方法 get() (重点) 查找方法，通过元素的 key 找到 value。\n代码如下：\npublic V get(Object key) { Node\u0026lt;K,V\u0026gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } get 方法主要调用的是 getNode 方法，代码如下：\nfinal Node\u0026lt;K,V\u0026gt; getNode(int hash, Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n; K k; // 如果哈希表不为空并且key对应的桶上不为空  if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; hash]) != null) { /* 判断数组元素是否相等 根据索引的位置检查第一个元素 注意：总是检查第一个元素 */ if (first.hash == hash \u0026amp;\u0026amp; // always check first node  ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; // 如果不是第一个元素，判断是否有后续结点  if ((e = first.next) != null) { // 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取结点  if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { // 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key  if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 小结：\n  get 方法实现的步骤：\na. 通过 hash 值获取该 key 映射到的桶 b. 桶上的 key 就是要查找的 key，则直接找到并返回 c. 桶上的 key 不是要找的 key，则查看后续的结点：\n\t如果后续结点是红黑树结点，通过调用红黑树的方法根据 key 获取 value 如果后续结点是链表结点，则通过循环遍历链表根据 key 获取 value   上述红黑树结点调用的是 getTreeNode 方法通过树形结点的 find 方法进行查找：\n  final TreeNode\u0026lt;K,V\u0026gt; getTreeNode(int h, Object k) { return ((parent != null) ? root() : this).find(h, k, null); } final TreeNode\u0026lt;K,V\u0026gt; find(int h, Object k, Class\u0026lt;?\u0026gt; kc) { TreeNode\u0026lt;K,V\u0026gt; p = this; do { int ph, dir; K pk; TreeNode\u0026lt;K,V\u0026gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) \u0026gt; h) p = pl; else if (ph \u0026lt; h) p = pr; else if ((pk = p.key) == k || (k != null \u0026amp;\u0026amp; k.equals(pk))) return p; // 找到之后直接返回  else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) \u0026amp;\u0026amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir \u0026lt; 0) ? pl : pr; // 递归查找  else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; } while (p != null); return null; }  查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。 这里和插入时一样，如果对比结点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。 若为树，则在树中通过key.equals(k)查找，O(logn)。若为链表，则在链表中通过key.equals(k)查找，O(n)。  4.3.6 遍历 HashMap 集合几种方式 1.分别遍历 Key 和 Values\nfor (String key : map.keySet()) { System.out.println(key); } for (Object vlaue : map.values() { System.out.println(value); } 2.使用 Iterator 迭代器迭代\nIterator\u0026lt;Map.Entry\u0026lt;String, Object\u0026gt;\u0026gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry\u0026lt;String, Object\u0026gt; mapEntry = iterator.next(); System.out.println(mapEntry.getKey() + \u0026#34;---\u0026#34; + mapEntry.getValue()); } 3.通过 get 方式（不建议使用）\nSet\u0026lt;String\u0026gt; keySet = map.keySet(); for (String str : keySet) { System.out.println(str + \u0026#34;---\u0026#34; + map.get(str)); } 说明：\n根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet 获取 Iterator一次，还有通过 get 又迭代一次，降低性能。\n jdk8 以后使用 Map 接口中的默认方法：  default void forEach(BiConsumer\u0026lt;? super K,? super V\u0026gt; action) // BiConsumer接口中的方法： \tvoid accept(T t, U u) 对给定的参数执行此操作。 参数 t - 第一个输入参数 u - 第二个输入参数 遍历代码：\nHashMap\u0026lt;String,String\u0026gt; map = new HashMap(); map.put(\u0026#34;001\u0026#34;, \u0026#34;zhangsan\u0026#34;); map.put(\u0026#34;002\u0026#34;, \u0026#34;lisi\u0026#34;); map.forEach((key, value) -\u0026gt; { System.out.println(key + \u0026#34;---\u0026#34; + value); }); 五、设计 HashMap 的初始化容量 5.1 问题描述 如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化 HashMap 的时候就应该指定它的容量，以防止 HashMap 自动扩容，影响使用效率。\n默认情况下 HashMap 的容量是 16，但是，如果用户通过构造函数指定了一个数字作为容量，那么 Hash 会选择大于该数字的第一个 2 的幂作为容量（3-\u0026gt;4、7-\u0026gt;8、9-\u0026gt;16）。这点我们在上述已经进行过讲解。\n5.2 《阿里巴巴Java开发手册》的建议 《阿里巴巴Java开发手册》原文：\n关于设置 HashMap 的初始化容量：\n我们上面介绍过，HashMap 的扩容机制，就是当达到扩容条件时会进行扩容。HashMap 的扩容条件就是当 HashMap 中的元素个数（size）超过临界值（threshold）时就会自动扩容。所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap 会有可能发生多次扩容，而 HashMap 中的扩容机制决定了每次扩容都需要重建 hash 表，是非常影响性能的。\n但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知 HashMap 中即将存放的 KV 个数的时候，容量设置成多少为好呢？\n关于设置 HashMap 的初始化容量大小：\n可以认为，当我们明确知道 HashMap 中元素的个数的时候，把默认容量设置成 initialCapacity/ 0.75F + 1.0F 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。\n而 Jdk 并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个 2 的幂。\n","permalink":"https://www.wilds.top/posts/52ce4309/","summary":"一、HashMap 集合简介   HashMap 基于 哈希表 (是根据关键码值(Key value)而直接进行访问的数据结构) 的 Map 接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null，此外，HashMap 中的映射不是有序的。\n  jdk1.8 之前 HashMap 由 数组 + 链表 组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突（两个对象调用的 hashCode 方法计算的哈希值一致导致计算的教组索引值相同）而存在的（“拉链法”解决冲突）。jdk1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。\n  补充：将链表转换成红黑树前会判断，即便阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树，而是选择逬行数组扩容。\n这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层阈值大于8并且数组长度大于64时，链表才转换为红黑树，具体可以参考 treeifyBin() 方法。\n当然,虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。\n  小结：\nHashMap 特点：\n 存储无序的。 键和值位置都可以是 null，但是键位置只能存在一个 null。 键位置是唯一的，是底层的数据结构控制的。 jdk1.8 前数据结构是链表+数组，jdk1.8 之后是链表+数组+红黑树。 阈值（边界值）\u0026gt; 8 并且数组长度大于 64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。    二、HashMap 集合底层的数据结构 2.1数据结构概念 数据结构是[计算机]存储、组织[数据]的方式。数据结构是指相互之间存在一种或多种特定关系的[数据元素]的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储[效率]。数据结构往往同高效的检索[算法]和[索引]技术有关。\n数据结构:就是存储数据的一种方式;\n2.2 存储数据的过程 示例代码：","title":"HashMap源码分析"},{"content":"一.为什么要优化 1.一个应用吞吐量瓶颈往往出现在数据库的处理速度上;\n2.随着应用程序的使用,数据库的数据逐渐增多,数据库处理压力不断增大;\n3.关系型数据库的数据是存放在磁盘上的,读写速度较慢(与内存中的数据相比);\n二.如何优化 1.表,字段的设计阶段,考量更优的存储和计算 1.1 对精度有要求,使用`decimal`  column_name `DECIMAL`(P,D); 在上面的语法中：\n P指的是整数部分加小数部分的总长度; D表示小数部分的位数，如果插入的值未指定小数部分或者小数部分不足D位则会自动补到D位小数，若插入的值小数部分超过了D位则会发生截断，截取前D位小数;  例如:column_name DECIMAL(6，2)表示列可以存储2位小数的6位数,因此,column_name列的范围是从-9999.99到9999.99;\n关于decimal详细用法: https://www.cnblogs.com/owenma/p/7097602.html\n1.2 字段尽可能使用 not null , null数值的计算逻辑比较复杂; 1.3 尽可能的使用 varchar 代替 char ，因为首先varchar 是变长字段,存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些; 1.4 在满足需求的前提下,字段数不要过多,字段注释是必要的,字段名见名知意,可以预留字段以备扩展; 1.5 第一范式, 字段原子性(默认就符合了); 1.6 第二范式, 消除主键的部分依赖; 1.7 第三范式, 消除对主键的传递依赖(高内聚,如商品表可分为商品简略信息表和商品详情表两张表);  2.数据库自身提供的优化功能,如索引 2.1 什么是索引\n从数据中提供的具有标识性的关键字,并且有对应数据的映射关系;  2.2 索引类型\n主键索引 primary key 要求关键字唯一且不为null; 普通索引 key 符合索引仅按照第一字段有序; 唯一索引 unique key 要求关键字唯一;  2.3 索引的使用场景\n索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引 应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描 值分布很稀少的字段不适合建索引，例如\u0026quot;性别\u0026quot;这种只有两三个值的字段 不用外键，由程序保证约束  2.4 mysql 添加索引命令\n1.PRIMARYKEY（主键索引）ALTERTABLE`table_name`ADDPRIMARYKEY(`column`)2.UNIQUE(唯一索引)ALTERTABLE`table_name`ADDUNIQUE(`column`)3.INDEX(普通索引)ALTERTABLE`table_name`ADDINDEXindex_name(`column`)4.FULLTEXT(全文索引)ALTERTABLE`table_name`ADDFULLTEXT(`column`)5.多列索引ALTERTABLE`table_name`ADDINDEXindex_name(`column1`,`column2`,`column3`)3.主从复制,读写分离 主从复制的概念\n 为了使用Mycat进行读写分离，我们先要配置MySQL数据库的主从复制。 从服务器自动同步主服务器的数据，从而达到数据一致。 进而，我们可以写操作时，只操作主服务器，而读操作，就可以操作从服务器了。 原理：主服务器在处理数据时，生成binlog日志，通过对日志的备份，实现从服务器的数据同步。  读写分离的概念\n 写操作只写入主服务器，读操作读取从服务器。  具体实现过程可参考: https://www.jianshu.com/p/1ac435a6510e\n4.针对慢查询进行sql语句优化 1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引; 2.应尽量避免在 where 子句中使用!=或\u0026lt;\u0026gt;操作符，否则将引擎放弃使用索引而进行全表扫描; 3.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描,如: select * from 表名 where num is null; 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select * from 表名 where num = 0; 4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描; 5.in 和 not in 也要慎用，否则会导致全表扫描,如:select * from 表名 where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了,如:select *from 表名 where num between 1 and 3 6.应尽量避免在 where 子句中对字段进行表达式操作,这将导致引擎放弃使用索引而进行全表扫描,如: select * from 表名 where num/2 = 100; 应改为: select * from 表名 where num = 100*2 ; 7.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 8.尽量使用数字型字段，若只含数字信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为\t引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 9.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索\t引，如一表中有性别字段gender，男、女几乎各一半，那么即使在gender上建了索引也对查询效率起不了作用。 10.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不\t常使用到的列上建的索引是否有必要。  5.大表拆分   分库分表的概念\n  将庞大的数据进行拆分\n  水平拆分：根据表的数据逻辑关系，将同一表中的数据按照某种条件，拆分到多台数据库服务器上，也叫做横向拆分。例如：一张1000万的大表，按照一模一样的结构，拆分成4个250万的小表，分别保存到4个数据库中。\n  垂直拆分：根据业务的维度，将不同的表切分到不同的数据库之上，也叫做纵向拆分。例如：所有的订单都保存到订单库中，所有的用户都保存到用户库中，同类型的表保存在同一库，不同的表分散在不同的库中。\n详情参考:https://blog.csdn.net/shiyong1949/article/details/59586773\n    ","permalink":"https://www.wilds.top/posts/3af29979/","summary":"一.为什么要优化 1.一个应用吞吐量瓶颈往往出现在数据库的处理速度上;\n2.随着应用程序的使用,数据库的数据逐渐增多,数据库处理压力不断增大;\n3.关系型数据库的数据是存放在磁盘上的,读写速度较慢(与内存中的数据相比);\n二.如何优化 1.表,字段的设计阶段,考量更优的存储和计算 1.1 对精度有要求,使用`decimal`  column_name `DECIMAL`(P,D); 在上面的语法中：\n P指的是整数部分加小数部分的总长度; D表示小数部分的位数，如果插入的值未指定小数部分或者小数部分不足D位则会自动补到D位小数，若插入的值小数部分超过了D位则会发生截断，截取前D位小数;  例如:column_name DECIMAL(6，2)表示列可以存储2位小数的6位数,因此,column_name列的范围是从-9999.99到9999.99;\n关于decimal详细用法: https://www.cnblogs.com/owenma/p/7097602.html\n1.2 字段尽可能使用 not null , null数值的计算逻辑比较复杂; 1.3 尽可能的使用 varchar 代替 char ，因为首先varchar 是变长字段,存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些; 1.4 在满足需求的前提下,字段数不要过多,字段注释是必要的,字段名见名知意,可以预留字段以备扩展; 1.5 第一范式, 字段原子性(默认就符合了); 1.6 第二范式, 消除主键的部分依赖; 1.7 第三范式, 消除对主键的传递依赖(高内聚,如商品表可分为商品简略信息表和商品详情表两张表);  2.数据库自身提供的优化功能,如索引 2.1 什么是索引\n从数据中提供的具有标识性的关键字,并且有对应数据的映射关系;  2.2 索引类型\n主键索引 primary key 要求关键字唯一且不为null; 普通索引 key 符合索引仅按照第一字段有序; 唯一索引 unique key 要求关键字唯一;  2.3 索引的使用场景\n索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引 应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描 值分布很稀少的字段不适合建索引，例如\u0026quot;性别\u0026quot;这种只有两三个值的字段 不用外键，由程序保证约束  2.","title":"MySQL优化"},{"content":"Docker服务相关命令   启动Docker服务\nsystemctl start docker   停止Docker服务\nsystemctl stop docker   重启Docker服务\nsystemctl restart docker   查看Docker服务状态\nsystemctl status docker   开机启动Docker服务\nsystemctl enable docker   Docker镜像相关命令   查看镜像\ndocker images   搜索镜像\ndocker search 镜像名称   下载镜像\ndocker pull 镜像名称:版本号   删除镜像\ndocker rmi 镜像名称:版本号/镜像ID   Docker容器相关命令   查看容器\ndocker ps\t//查看正在运行的容器 docker ps -a\t//查看所有容器(包括已经停止的容器   创建容器\n 交互式容器:创建完这个容器后 容器会立即启动 并且自动进入到容器内部 退出容器后容器会自动关闭-it 代表创建的容器是交互式的  docker run -it --name=容器的名称 镜像名称:版本号 /bin/bash  守护式容器: 创建完这个容器后 容器会立即启动 不会自动进入到容器内部 退出容器后容器会不会关 闭-id 代表创建的容器是守护式的  docker run -id --name=容器的名称 镜像名称:版本号  创建式容器:创建完这个容器不会立即启动 也不会进入到容器内部  docker create --name=容器名称 镜像名称:版本   进入容器\ndocker exec -it 容器名称/容器ID /bin/bash   启动容器\ndocker start 容器名称/容器ID   停止容器\ndocker stop 容器名称/容器ID   删除容器\ndocker rm 容器名称/容器ID   查看容器信息\ndocker inspect 容器名称/容器ID   容器导出为镜像\ndocker commit 容器名称 镜像名称   镜像导出为压缩文件\ndocker save –o tar文件名 镜像名   导入压缩文件为镜像\ndocker load -i tar文件名   ","permalink":"https://www.wilds.top/posts/e32c011c/","summary":"Docker服务相关命令   启动Docker服务\nsystemctl start docker   停止Docker服务\nsystemctl stop docker   重启Docker服务\nsystemctl restart docker   查看Docker服务状态\nsystemctl status docker   开机启动Docker服务\nsystemctl enable docker   Docker镜像相关命令   查看镜像\ndocker images   搜索镜像\ndocker search 镜像名称   下载镜像\ndocker pull 镜像名称:版本号   删除镜像\ndocker rmi 镜像名称:版本号/镜像ID   Docker容器相关命令   查看容器\ndocker ps\t//查看正在运行的容器 docker ps -a\t//查看所有容器(包括已经停止的容器   创建容器","title":"Docker笔记"},{"content":"Lambda简介 Lambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。\nJDK 也提供了大量的内置函数式接口供我们使用，使得 Lambda 表达式的运用更加方便、高效。\n对接口的要求 虽然使用 Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。Lambda 规定接口中只能有一个需要被实现的方法，不是规定接口中只能有一个方法\n jdk 8 中有另一个新特性：default， 被 default 修饰的方法会有默认实现，不是必须被实现的方法，所以不影响 Lambda 表达式的使用。\n @FunctionalInterface 修饰函数式接口的，要求接口中的抽象方法只有一个。 这个注解往往会和 lambda 表达式一起出现。\nLambda 基础语法 我们这里给出六个接口，后文的全部操作都利用这六个接口来进行阐述。\n/**多参数无返回*/ @FunctionalInterface public interface NoReturnMultiParam { void method(int a, int b); } /**无参无返回值*/ @FunctionalInterface public interface NoReturnNoParam { void method(); } /**一个参数无返回*/ @FunctionalInterface public interface NoReturnOneParam { void method(int a); } /**多个参数有返回值*/ @FunctionalInterface public interface ReturnMultiParam { int method(int a, int b); } /*** 无参有返回*/ @FunctionalInterface public interface ReturnNoParam { int method(); } /**一个参数有返回值*/ @FunctionalInterface public interface ReturnOneParam { int method(int a); } Lambda语法由三部分组成：() -\u0026gt; {}\n参数块：就是前面的 ()，就是简单地把要实现的抽象方法的参数原封不动写在这。\n小箭头：就是 -\u0026gt; 这个符号。\n代码块：就是{}要实现的方法原封不动写在这。\nimport lambda.interfaces.*; public class Test { public static void main(String[] args) { //无参无返回  NoReturnNoParam noReturnNoParam = () -\u0026gt; { System.out.println(\u0026#34;无参无返回\u0026#34;); }; noReturnNoParam.method(); //一个参数无返回  NoReturnOneParam noReturnOneParam = (int a) -\u0026gt; { System.out.println(\u0026#34;一个参数无返回:\u0026#34; + a); }; noReturnOneParam.method(6); //多个参数无返回  NoReturnMultiParam noReturnMultiParam = (int a, int b) -\u0026gt; { System.out.println(\u0026#34;多个参数无返回:\u0026#34; + \u0026#34;{\u0026#34; + a +\u0026#34;,\u0026#34; + + b +\u0026#34;}\u0026#34;); }; noReturnMultiParam.method(6, 8); //无参有返回值  ReturnNoParam returnNoParam = () -\u0026gt; { System.out.print(\u0026#34;无参有返回值\u0026#34;); return 1; }; int res = returnNoParam.method(); System.out.println(\u0026#34;return:\u0026#34; + res); //一个参数有返回值  ReturnOneParam returnOneParam = (int a) -\u0026gt; { System.out.println(\u0026#34;一个参数有返回值:\u0026#34; + a); return 1; }; int res2 = returnOneParam.method(6); System.out.println(\u0026#34;return:\u0026#34; + res2); //多个参数有返回值  ReturnMultiParam returnMultiParam = (int a, int b) -\u0026gt; { System.out.println(\u0026#34;多个参数有返回值:\u0026#34; + \u0026#34;{\u0026#34; + a + \u0026#34;,\u0026#34; + b +\u0026#34;}\u0026#34;); return 1; }; int res3 = returnMultiParam.method(6, 8); System.out.println(\u0026#34;return:\u0026#34; + res3); } } Lambda 语法简化 我们可以通过观察以下代码来完成代码的进一步简化，写出更加优雅的代码。\nimport lambda.interfaces.*; public class Test { public static void main(String[] args) { //1.简化参数类型，可以不写参数类型，但是必须所有参数都不写  NoReturnMultiParam lamdba1 = (a, b) -\u0026gt; { System.out.println(\u0026#34;简化参数类型\u0026#34;); }; lamdba1.method(1, 2); //2.简化参数小括号，如果只有一个参数则可以省略参数小括号  NoReturnOneParam lambda2 = a -\u0026gt; { System.out.println(\u0026#34;简化参数小括号\u0026#34;); }; lambda2.method(1); //3.简化方法体大括号，如果方法条只有一条语句，则可以胜率方法体大括号  NoReturnNoParam lambda3 = () -\u0026gt; System.out.println(\u0026#34;简化方法体大括号\u0026#34;); lambda3.method(); //4.如果方法体只有一条语句，并且是 return 语句，则可以省略方法体大括号  ReturnOneParam lambda4 = a -\u0026gt; a+3; System.out.println(lambda4.method(5)); ReturnMultiParam lambda5 = (a, b) -\u0026gt; a+b; System.out.println(lambda5.method(1, 1)); } } Lambda 表达式常用示例  lambda 表达式引用方法  有时候我们不是必须要自己重写某个匿名内部类的方法，我们可以可以利用 lambda表达式的接口快速指向一个已经被实现的方法。\n语法\n方法归属者::方法名 静态方法的归属者为类名，普通方法归属者为对象\npublic class Exe1 { public static void main(String[] args) { ReturnOneParam lambda1 = a -\u0026gt; doubleNum(a); System.out.println(lambda1.method(3)); //lambda2 引用了已经实现的 doubleNum 方法  ReturnOneParam lambda2 = Exe1::doubleNum; System.out.println(lambda2.method(3)); Exe1 exe = new Exe1(); //lambda4 引用了已经实现的 addTwo 方法  ReturnOneParam lambda4 = exe::addTwo; System.out.println(lambda4.method(2)); } /** * 要求 * 1.参数数量和类型要与接口中定义的一致 * 2.返回值类型要与接口中定义的一致 */ public static int doubleNum(int a) { return a * 2; } public int addTwo(int a) { return a + 2; } }  构造方法的引用  一般我们需要声明接口，该接口作为对象的生成器，通过 类名::new 的方式来实例化对象，然后调用方法返回对象。\ninterface ItemCreatorBlankConstruct { Item getItem(); } interface ItemCreatorParamContruct { Item getItem(int id, String name, double price); } public class Exe2 { public static void main(String[] args) { ItemCreatorBlankConstruct creator = () -\u0026gt; new Item(); Item item = creator.getItem(); ItemCreatorBlankConstruct creator2 = Item::new; Item item2 = creator2.getItem(); ItemCreatorParamContruct creator3 = Item::new; Item item3 = creator3.getItem(112, \u0026#34;鼠标\u0026#34;, 135.99); } }  lambda 表达式创建线程  我们以往都是通过创建 Thread 对象，然后通过匿名内部类重写 run() 方法，一提到匿名内部类我们就应该想到可以使用 lambda 表达式来简化线程的创建过程。\nThread t = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10; i++) { System.out.println(2 + \u0026#34;:\u0026#34; + i); } }); t.start();  遍历集合  我们可以调用集合的 public void forEach(Consumer\u0026lt;? super E\u0026gt; action) 方法，通过 lambda 表达式的方式遍历集合中的元素。以下是 Consumer 接口的方法以及遍历集合的操作。Consumer 接口是 jdk 为我们提供的一个函数式接口。\n@FunctionalInterface public interface Consumer\u0026lt;T\u0026gt; { void accept(T t); //....  } Copy ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(list, 1,2,3,4,5); //lambda表达式 方法引用  list.forEach(System.out::println); list.forEach(element -\u0026gt; { if (element % 2 == 0) { System.out.println(element); } });  删除集合中的某个元素  我们通过public boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter)方法来删除集合中的某个元素，Predicate 也是 jdk 为我们提供的一个函数式接口，可以简化程序的编写。\nArrayList\u0026lt;Item\u0026gt; items = new ArrayList\u0026lt;\u0026gt;(); items.add(new Item(11, \u0026#34;小牙刷\u0026#34;, 12.05 )); items.add(new Item(5, \u0026#34;日本马桶盖\u0026#34;, 999.05 )); items.add(new Item(7, \u0026#34;格力空调\u0026#34;, 888.88 )); items.add(new Item(17, \u0026#34;肥皂\u0026#34;, 2.00 )); items.add(new Item(9, \u0026#34;冰箱\u0026#34;, 4200.00 )); items.removeIf(ele -\u0026gt; ele.getId() == 7); //通过 foreach 遍历，查看是否已经删除  items.forEach(System.out::println);  集合内元素的排序  在以前我们若要为集合内的元素排序，就必须调用 sort 方法，传入比较器匿名内部类重写 compare 方法，我们现在可以使用 lambda 表达式来简化代码。\nArrayList\u0026lt;Item\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new Item(13, \u0026#34;背心\u0026#34;, 7.80)); list.add(new Item(11, \u0026#34;半袖\u0026#34;, 37.80)); list.add(new Item(14, \u0026#34;风衣\u0026#34;, 139.80)); list.add(new Item(12, \u0026#34;秋裤\u0026#34;, 55.33)); /* list.sort(new Comparator\u0026lt;Item\u0026gt;() { @Override public int compare(Item o1, Item o2) { return o1.getId() - o2.getId(); } }); */ list.sort((o1, o2) -\u0026gt; o1.getId() - o2.getId()); System.out.println(list); Lambda 表达式中的闭包问题 这个问题我们在匿名内部类中也会存在，如果我们把注释放开会报错，告诉我 num 值是 final 不能被改变。这里我们虽然没有标识 num 类型为 final，但是在编译期间虚拟机会帮我们加上 final 修饰关键字。\nimport java.util.function.Consumer; public class Main { public static void main(String[] args) { int num = 10; Consumer\u0026lt;String\u0026gt; consumer = ele -\u0026gt; { System.out.println(num); }; //num = num + 2;  consumer.accept(\u0026#34;hello\u0026#34;); } } 总结 学会理解和写 Lambda 表达式的三步:\n1. 确认 Lambda 表达式的类型:\n 能用 Lambda 表达式来表示的类型，必须是一个函数式接口，而函数式接口，就是只有一个抽象方法的接口。  2. 找到要实现的方法:\n Lambda 表达式就是实现一个方法，什么方法呢？就是刚刚那些函数式接口中的抽象方法  3. 实现这个方法:\n Lambda 表达式就是要实现这个抽象方法，如果不用 Lambda 表达式，你一定知道用匿名类如何去实现  Lambda 表达式的类型就是函数式接口，要实现的方法就是函数式接口里那个唯一的抽象方法，实现这个方法的方式就是参数块 + 小箭头 + 方法体，其中参数块和方法体都可以一定程度上简化它的写法。\n","permalink":"https://www.wilds.top/posts/ff79dbf8/","summary":"Lambda简介 Lambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。\nJDK 也提供了大量的内置函数式接口供我们使用，使得 Lambda 表达式的运用更加方便、高效。\n对接口的要求 虽然使用 Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。Lambda 规定接口中只能有一个需要被实现的方法，不是规定接口中只能有一个方法\n jdk 8 中有另一个新特性：default， 被 default 修饰的方法会有默认实现，不是必须被实现的方法，所以不影响 Lambda 表达式的使用。\n @FunctionalInterface 修饰函数式接口的，要求接口中的抽象方法只有一个。 这个注解往往会和 lambda 表达式一起出现。\nLambda 基础语法 我们这里给出六个接口，后文的全部操作都利用这六个接口来进行阐述。\n/**多参数无返回*/ @FunctionalInterface public interface NoReturnMultiParam { void method(int a, int b); } /**无参无返回值*/ @FunctionalInterface public interface NoReturnNoParam { void method(); } /**一个参数无返回*/ @FunctionalInterface public interface NoReturnOneParam { void method(int a); } /**多个参数有返回值*/ @FunctionalInterface public interface ReturnMultiParam { int method(int a, int b); } /*** 无参有返回*/ @FunctionalInterface public interface ReturnNoParam { int method(); } /**一个参数有返回值*/ @FunctionalInterface public interface ReturnOneParam { int method(int a); } Lambda语法由三部分组成：() -\u0026gt; {}","title":"Lambda表达式"},{"content":"一、下载镜像   黑果小兵\n  二、下载EFI   EFI远景论坛大佬制作\n  三、制作启动盘   将U盘文件备份，然后进行格式化\n U盘必须在16G及以上\n   四、修改启动盘中的EFI文件  使用DiskGenus进行文件替换    将EFI文件全部删除，然后将下载好的EFI文件放进去\n  五、修改ESP分区大小  使用DiskGenus扩容win自带ESP分区，可以将ESP分区直接删除，然后新建500M的ESP分区，并使用DISM++进行引导恢复（双硬盘可直接在另一个盘新建ESP分区）  六、准备安装磁盘  使用DiskGenus划分出要安装macOS的磁盘  七、关闭安全启动   开机狂按F10进入BIOS设置-\u0026gt;选择系统设置-\u0026gt;选择启动选项-\u0026gt;修改安全启动模式为禁用\n  八、开始安装  开机选择U盘启动，狂按F9键进入，选择制作的启动盘里的启动选项，选择第一个，第二个为PE的启动项    进入OC引导界面，选择安装install macos\n  进入到启动界面\n  选择简体中文\n  首先选择磁盘工具将之前划分出来的分区进行格式化\n  找到划分的分区，根据大小和位置判断\n  点击上方的抹除，名称随意，固态硬盘格式选择APFS（机械硬盘选择MacOS日志），如果EFI分区过小会出现抹除失败\n  接下来就可以进行系统安装了\n  一路下一步，协议全部同意\n  安装过程会自动重启，此时第二次进到OC引导界面，选择新增的macOS install选项\n  进入开机界面，稍后会再次重启\n 这里会重启多次，每次重启依然选择macOS install选项，直到出现这个选项消失，此时出现macOS系统盘选项，这时已安装完成，可以开机进入系统了\n   开机进入，一路下一步，不要登录账号，不要开启定位\n  安装完成，进入桌面\n  九、将EFI文件放入ESP分区中   将U盘中能顺利安装并启动macOS的EFI放到硬盘的ESP分区里，这里采用黑果小兵提供的挂载方法，方便以后替换EFI文件（也可直接使用DiskGenus将文件EFI文件放入\n  在Windows操作系统下面,以系统管理员身份打开cmd窗口,输入命令:\nc:\\\u0026gt;diskpart list disk # 磁盘列表 select disk n # 选择EFI分区所在的磁盘，n为磁盘号 list partition # 磁盘分区列表 select partition n # 选择EFI分区，n为EFI分区号 set id=\u0026#34;ebd0a0a2-b9e5-4433-87c0-68b6b72699c7\u0026#34;\t# 设置为基本数据分区 assign letter=X # x为EFI分区盘符 exit\t# 退出diskpart notepad\t  执行完重启一次，之后就可以直接替换文件了\n  十、修改启动选项  使用DiskGenus修改启动项顺序，将opencore引导放在首位  ","permalink":"https://www.wilds.top/posts/99c03bb5/","summary":"一、下载镜像   黑果小兵\n  二、下载EFI   EFI远景论坛大佬制作\n  三、制作启动盘   将U盘文件备份，然后进行格式化\n U盘必须在16G及以上\n   四、修改启动盘中的EFI文件  使用DiskGenus进行文件替换    将EFI文件全部删除，然后将下载好的EFI文件放进去\n  五、修改ESP分区大小  使用DiskGenus扩容win自带ESP分区，可以将ESP分区直接删除，然后新建500M的ESP分区，并使用DISM++进行引导恢复（双硬盘可直接在另一个盘新建ESP分区）  六、准备安装磁盘  使用DiskGenus划分出要安装macOS的磁盘  七、关闭安全启动   开机狂按F10进入BIOS设置-\u0026gt;选择系统设置-\u0026gt;选择启动选项-\u0026gt;修改安全启动模式为禁用\n  八、开始安装  开机选择U盘启动，狂按F9键进入，选择制作的启动盘里的启动选项，选择第一个，第二个为PE的启动项    进入OC引导界面，选择安装install macos\n  进入到启动界面\n  选择简体中文\n  首先选择磁盘工具将之前划分出来的分区进行格式化\n  找到划分的分区，根据大小和位置判断\n  点击上方的抹除，名称随意，固态硬盘格式选择APFS（机械硬盘选择MacOS日志），如果EFI分区过小会出现抹除失败\n  接下来就可以进行系统安装了","title":"Hackintosh安装"},{"content":"效果图   软件商店界面\n  所有插件正常使用\n  破解步骤   打开宝塔文件管理，找到路径  /www/server/panel/class'下的panelPlugin.py文件，双击进行编辑，找到图示位置，约336行：\n  添加以下代码，格式要一致\nfor soft in softList[\u0026#39;list\u0026#39;]: soft[\u0026#39;endtime\u0026#39;] = 0 如图所示，修改完后保存\n  回到首页重启面板，到软件商品就能看到效果了\n  ","permalink":"https://www.wilds.top/posts/9f22989d/","summary":"效果图   软件商店界面\n  所有插件正常使用\n  破解步骤   打开宝塔文件管理，找到路径  /www/server/panel/class'下的panelPlugin.py文件，双击进行编辑，找到图示位置，约336行：\n  添加以下代码，格式要一致\nfor soft in softList[\u0026#39;list\u0026#39;]: soft[\u0026#39;endtime\u0026#39;] = 0 如图所示，修改完后保存\n  回到首页重启面板，到软件商品就能看到效果了\n  ","title":"宝塔破解面板破解"},{"content":" ​\tOneManager是一种能够挂载多种网盘的程序，可以通过网站直接去访问onedrive的文件，从而实现直链下载，网页在线观看视频等。\n​\t前提条件：onedrive账号，VPS一台。\n​\t项目地址oneManager, oneManager的部署方式有很多种，本文主要介绍在VPS上利用宝塔面板来部署的方法。\n   首先进入宝塔首页，安装好基本运行环境Nginx和PHP,然后进入网站页面\n  点击添加站点，填好域名，PHP版本随意\n  点击根目录进入网站文件地址\n  进入oneManager项目地址将项目压缩包下载到本地\n  然后进入宝塔将压缩包上传到网站根目录\n  上传完成后将压缩包解压，得到网站文件\n  然后打开网站设置修改网站目录\n  并进行伪静态设置\nNginx伪静态规则\nrewrite ^/(.*) /index.php?/$1 last; Apache伪静态规则\nRewriteEngine On RewriteRule ^(.*) index.php?/$1 [L]   网站设置到这来就结束了，接下来访问网站域名进行oneManager程序安装与网盘挂载\n  选择简体中文\n  确认已启用伪静态\n  然后设置网站管理员密码\n  接着进入首页点击登录进入后台管理页面\n  选择onedrive然后点击添加盘，输入基本信息\n  接着登录onedrive账号\n  获取权限\n  到这里就安装完成了，然后进入后台可以进行一些个性化设置\n  ","permalink":"https://www.wilds.top/posts/0adbf5e5/","summary":"​\tOneManager是一种能够挂载多种网盘的程序，可以通过网站直接去访问onedrive的文件，从而实现直链下载，网页在线观看视频等。\n​\t前提条件：onedrive账号，VPS一台。\n​\t项目地址oneManager, oneManager的部署方式有很多种，本文主要介绍在VPS上利用宝塔面板来部署的方法。\n   首先进入宝塔首页，安装好基本运行环境Nginx和PHP,然后进入网站页面\n  点击添加站点，填好域名，PHP版本随意\n  点击根目录进入网站文件地址\n  进入oneManager项目地址将项目压缩包下载到本地\n  然后进入宝塔将压缩包上传到网站根目录\n  上传完成后将压缩包解压，得到网站文件\n  然后打开网站设置修改网站目录\n  并进行伪静态设置\nNginx伪静态规则\nrewrite ^/(.*) /index.php?/$1 last; Apache伪静态规则\nRewriteEngine On RewriteRule ^(.*) index.php?/$1 [L]   网站设置到这来就结束了，接下来访问网站域名进行oneManager程序安装与网盘挂载\n  选择简体中文\n  确认已启用伪静态\n  然后设置网站管理员密码\n  接着进入首页点击登录进入后台管理页面\n  选择onedrive然后点击添加盘，输入基本信息\n  接着登录onedrive账号\n  获取权限\n  到这里就安装完成了，然后进入后台可以进行一些个性化设置","title":"OneManager搭建教程"},{"content":"美化效果 前提条件   Windows Terminal美化的基础就是Powerline。Powerline提供自定义的命令提示符体验，提供 Git 状态颜色编码和提示符。成功安装需要具备三个条件：\n 安装Powerline字形——Meslo LGM NF 安装 Posh-Git-————将 Git 状态信息添加到提示，并为 Git 命令、参数、远程和分支名称添加 tab 自动补全 安装Oh-My-Posh———为 PowerShell 提示符提供主题功能\n   安装字体   在Nerd Fonts选择喜欢的字体下载到** Windows** ，并进行安装。\n  进入PowerShell设置选择刚刚安装的字体,然后保存\n  安装 posh-git 以及 oh-my-posh   如果尚未安装Git for Windows，请安装适用于 Windows 的Git。\n  以管理员权限运行PowerShell，安装 Posh-Git 和 Oh-My-Posh\nInstall-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser  对于安装过程中出现的提示信息，全部选择 [Y]“是”\n   在PowerShell中设置Powerline   在PowerShell中输入notepad $profile,用记事本打开PowerShell配置文件，如果你没设置过 PowerShell，那么这条命令会为你创建一个新的配置文件 Microsoft.PowerShell_profile.ps1 ，这个文件是一个脚本，该脚本在每次启动 PowerShell时运行。\n  在PowerShell配置文件中加入下面内容\nSet-PoshPrompt -Theme agnoster Import-Module posh-git Import-Module oh-my-posh   添加配色方案   打开iTerm2-Color-Schemes，找到windowsterminal\n  打开文件中的Json文件，复制全部内容\n  点击PowerShell设置中的按钮编辑配置文件\n  找到**\u0026ldquo;schemes\u0026rdquo;**这一行\n  在[]中的最后一行上面的{}后面加上英文,然后粘贴上面复制的内容，最后进行保存\n  最后在PowerShell主题设置中找到刚刚添加的配色并进行应用保存\n  ","permalink":"https://www.wilds.top/posts/353f4593/","summary":"美化效果 前提条件   Windows Terminal美化的基础就是Powerline。Powerline提供自定义的命令提示符体验，提供 Git 状态颜色编码和提示符。成功安装需要具备三个条件：\n 安装Powerline字形——Meslo LGM NF 安装 Posh-Git-————将 Git 状态信息添加到提示，并为 Git 命令、参数、远程和分支名称添加 tab 自动补全 安装Oh-My-Posh———为 PowerShell 提示符提供主题功能\n   安装字体   在Nerd Fonts选择喜欢的字体下载到** Windows** ，并进行安装。\n  进入PowerShell设置选择刚刚安装的字体,然后保存\n  安装 posh-git 以及 oh-my-posh   如果尚未安装Git for Windows，请安装适用于 Windows 的Git。\n  以管理员权限运行PowerShell，安装 Posh-Git 和 Oh-My-Posh\nInstall-Module posh-git -Scope CurrentUser Install-Module oh-my-posh -Scope CurrentUser  对于安装过程中出现的提示信息，全部选择 [Y]“是”\n   在PowerShell中设置Powerline   在PowerShell中输入notepad $profile,用记事本打开PowerShell配置文件，如果你没设置过 PowerShell，那么这条命令会为你创建一个新的配置文件 Microsoft.","title":"WindowsTerminal美化"},{"content":"Ctrl 快捷键 JAVA Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备） Ctrl + E 显示最近打开的文件记录列表 （必备） Ctrl + N 根据输入的 名/类名 查找类文件 （必备） Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 （必备） Ctrl + P 方法参数提示显示 （必备） JAVA Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 （必备） Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备） Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） JAVA Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码处显示错误信息 （必备） Ctrl + F3 调转到所选中的词的下一个引用位置 （必备） Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备） Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上 delete，则是关闭对应选中的窗口 JAVA Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl +逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 （必备） Ctrl +BackSpace 删除光标前面的单词或是中文句 （必备） Ctrl +1,2,3...9 定位到对应数值的书签位置 （必备） Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 （必备） Ctrl + 光标定位按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 （必备） Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 （必备） Ctrl + 前方向键 等效于鼠标滚轮向前效果 （必备） Ctrl + 后方向键 等效于鼠标滚轮向后效果 （必备） Alt 快捷键 JAVA Alt + ` 显示版本控制常用操作菜单弹出层 （必备） Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备） Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备） Alt + 左方向键 切换当前已打开的窗口中的子视图，比如 Debug 窗口中有 Output、Debugger 等子视图，用此快捷键就可以在子视图中切换 （必备） Alt + 右方向键 按切换当前已打开的窗口中的子视图，比如 Debug 窗口中有 Output、Debugger 等子视图，用此快捷键就可以在子视图中切换 （必备） Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 （必备） Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 （必备） Alt +1,2,3...9 显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备） Shift 快捷键 JAVA Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新 Windows 窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 （必备） Shift + Tab 取消缩进 （必备） Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备） Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备） Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 （必备） Ctrl + Alt 快捷键 JAVA Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 （必备） Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + V 快速引进变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 （必备） Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 JAVA Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 （必备） Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 Ctrl + Shift 快捷键 JAVA Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备） JAVA Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 （必备） Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + B 跳转到类型声明处 （必备） Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 （必备） Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 （必备） Ctrl + Shift + + 展开所有代码 （必备） Ctrl + Shift + - 折叠所有代码 （必备） JAVA Ctrl + Shift + F7 高亮显示所有该选中文本，按 Esc 高亮消失 （必备） Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F12 编辑器最大化 （必备） Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift +Backspace 退回到上次修改的地方 （必备） Ctrl + Shift +1,2,3...9 快速添加指定数值的书签 （必备） Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备） JAVA Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句（必备） Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句（必备） Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备） Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备） Alt + Shift 快捷键 JAVA Alt + Shift + N 选择 / 添加 task （必备） Alt + Shift + F 显示添加到收藏夹弹出层 / 添加到收藏夹 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + I 查看项目当前文件 Alt + Shift + F7在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备） Alt + Shift + 前方向键 移动光标所在行向上移动 （必备） Alt + Shift + 后方向键 移动光标所在行向下移动 （必备） Ctrl + Shift + Alt 快捷键 JAVA Ctrl + Shift + Alt + V 无格式黏贴 （必备） Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 （必备） Ctrl + Shift + Alt + C 复制参考信息 其他快捷键 JAVA F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 （必备） F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 F11 添加书签 （必备） F12 回到前一个工具窗口 （必备） Tab缩进 （必备） ESC 从工具窗口进入代码文件窗口 （必备） 连按两次Shift 弹出 Search Everywhere 弹出层 ","permalink":"https://www.wilds.top/posts/64a1faea/","summary":"Ctrl 快捷键 JAVA Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围（必备） Ctrl + E 显示最近打开的文件记录列表 （必备） Ctrl + N 根据输入的 名/类名 查找类文件 （必备） Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 （必备） Ctrl + P 方法参数提示显示 （必备） JAVA Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 （必备） Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备） Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） JAVA Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码处显示错误信息 （必备） Ctrl + F3 调转到所选中的词的下一个引用位置 （必备） Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备） Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上 delete，则是关闭对应选中的窗口 JAVA Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl +逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 （必备） Ctrl +BackSpace 删除光标前面的单词或是中文句 （必备） Ctrl +1,2,3.","title":"IDEA常用快捷键"},{"content":"Java概述 何为编程 编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。\n为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。\n什么是Java Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。\njdk1.5之后的三大版本  Java SE（J2SE，Java 2 Platform Standard Edition，标准版） Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。 Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版） Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE Java ME（J2ME，Java 2 Platform Micro Edition，微型版） Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。  JVM、JRE和JDK的关系 JVM\nJava Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。\nJRE\nJava Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包\n如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。\nJDK\nJava Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等\nJVM\u0026amp;JRE\u0026amp;JDK关系图\n什么是跨平台性？原理是什么 所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。\n实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。\nJava语言有哪些特点 简单易学（Java语言的语法与C语言和C++语言很接近）\n面向对象（封装，继承，多态）\n平台无关性（Java虚拟机实现平台无关性）\n支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）\n支持多线程（多线程机制使应用程序在同一时间并行执行多项任）\n健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）\n安全性\n什么是字节码？采用字节码的最大好处是什么 字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。\n采用字节码的好处：\nJava语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\n先看下java中的编译器和解释器：\nJava中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。\nJava源代码----\u0026gt;编译器----\u0026gt;jvm可执行的Java字节码(即虚拟指令)----\u0026gt;jvm----\u0026gt;jvm中解释器-----\u0026gt;机器可执行的二进制机器码----\u0026gt;程序运行。 什么是Java程序的主类？应用程序和小程序的主类有何不同？ 一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。\nJava应用程序与小程序之间有那些差别？ 简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。\nJava和C++的区别 我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！\n 都是面向对象的语言，都支持封装、继承和多态 Java不提供指针来直接访问内存，程序内存更加安全 Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。 Java有自动内存管理机制，不需要程序员手动释放无用内存  Oracle JDK 和 OpenJDK 的对比  Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次； OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题； 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能； Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。  基础语法 数据类型 Java有哪些数据类型 定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。\n分类\n  基本数据类型\n   数值型       整数类型(byte,short,int,long) 浮点类型(float,double)       字符型(char) 布尔型(boolean)    引用数据类型\n   类(class) 接口(interface) 数组([])    Java基本数据类型图\n\nswitch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。\n用最有效率的方法计算 2 乘以 8 2 \u0026laquo; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。\nMath.round(11.5) 等于多少？Math.round(-11.5)等于多少 Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。\nfloat f=3.4;是否正确 不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。\nshort s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗 对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。\n而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。\n编码 Java语言采用何种编码方案？有何特点？ Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。\n注释 什么Java注释 定义：用于解释说明程序的文字\n分类\n 单行注释 格式： // 注释文字 多行注释 格式： /* 注释文字 */ 文档注释 格式：/** 注释文字 */  作用\n在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。\n注意事项：多行和文档注释都不能嵌套使用。\n访问修饰符 访问修饰符 public,private,protected,以及不写（默认）时的区别 定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n分类\nprivate : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\ndefault (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\nprotected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\npublic : 对所有类可见。使用对象：类、接口、变量、方法\n访问修饰符图\n\n运算符 \u0026amp;和\u0026amp;\u0026amp;的区别 \u0026amp;运算符有两种用法：(1)按位与；(2)逻辑与。\n\u0026amp;\u0026amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。\u0026amp;\u0026amp;之所以称为短路运算，是因为如果\u0026amp;\u0026amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。\n注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。\n关键字 Java 有没有 goto goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。\nfinal 有什么用？ 用于修饰类、属性和方法；\n 被final修饰的类不可以被继承 被final修饰的方法不可以被重写 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的  final finally finalize区别  final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。 finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。 finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的 最后判断。  this关键字的用法 this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。\nthis的用法在java中大体可以分为3种：\n1.普通的直接引用，this相当于是指向当前对象本身。\n2.形参与成员名字重名，用this来区分：\npublic Person(String name, int age) { this.name = name; this.age = age; } 3.引用本类的构造函数\nclass Person{ private String name; private int age; public Person() { } public Person(String name) { this.name = name; } public Person(String name, int age) { this(name); this.age = age; } } super关键字的用法 super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。\nsuper也有三种用法：\n1.普通的直接引用\n与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。\n2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分\nclass Person{ protected String name; public Person(String name) { this.name = name; } } class Student extends Person{ private String name; public Student(String name, String name1) { super(name); this.name = name1; } public void getInfo(){ System.out.println(this.name); //Child System.out.println(super.name); //Father } } public class Test { public static void main(String[] args) { Student s1 = new Student(\u0026quot;Father\u0026quot;,\u0026quot;Child\u0026quot;); s1.getInfo(); } } 3.引用父类构造函数\n super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。  this与super的区别  super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。  static存在的主要意义 static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！\nstatic关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。\n为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。\nstatic的独特之处 1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。\n 怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？\n 2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。\n3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！\n4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。\nstatic应用场景 因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。\n因此比较常见的static应用场景有：\n 1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包\n static注意事项 1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。\n流程控制语句 break ,continue ,return 的区别及作用 break 跳出总上一层循环，不再执行循环(结束当前的循环体)\ncontinue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)\nreturn 程序返回，不再执行下面的代码(结束当前的方法 直接返回)\n在 Java 中，如何跳出当前的多重嵌套循环 在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：\npublic static void main(String[] args) { ok: for (int i = 0; i \u0026lt; 10; i++) { for (int j = 0; j \u0026lt; 10; j++) { System.out.println(\u0026quot;i=\u0026quot; + i + \u0026quot;,j=\u0026quot; + j); if (j == 5) { break ok; } } } } 面向对象 面向对象概述 面向对象和面向过程的区别 面向过程：\n优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。\n缺点：没有面向对象易维护、易复用、易扩展\n面向对象：\n优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护\n缺点：性能比面向过程低\n面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。\n面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。\n面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。\n面向对象三大特性 面向对象的特征有哪些方面 面向对象的特征主要有以下几个方面：\n抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。\n封装\n封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。\n继承\n继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。\n关于继承如下 3 点请记住：\n 子类拥有父类非 private 的属性和方法。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。  多态\n所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。\n在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。\n其中Java 面向对象编程三大特性：封装 继承 多态\n封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。\n继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。\n关于继承如下 3 点请记住：\n 子类拥有父类非 private 的属性和方法。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。  多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。\n在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。\n方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。\n一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：\n 方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。  什么是多态机制？Java语言是如何实现多态的？ 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。\n多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。\n多态的实现\nJava实现多态有三个必要条件：继承、重写、向上转型。\n继承：在多态中必须存在有继承关系的子类和父类。\n重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。\n面向对象五大基本原则是什么（可选）  单一职责原则SRP(Single Responsibility Principle) 类的功能要单一，不能包罗万象，跟杂货铺似的。 开放封闭原则OCP(Open－Close Principle) 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。 里式替换原则LSP(the Liskov Substitution Principle LSP) 子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~ 依赖倒置原则DIP(the Dependency Inversion Principle DIP) 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。 接口分离原则ISP(the Interface Segregation Principle ISP) 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。  类与接口 抽象类和接口的对比 抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。\n从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。\n相同点\n 接口和抽象类都不能实例化 都位于继承的顶端，用于被其他实现或继承 都包含抽象方法，其子类都必须覆写这些抽象方法  不同点\n备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。\n现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。\n接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：\n 行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。  普通类和抽象类有哪些区别？  普通类不能包含抽象方法，抽象类可以包含抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。  抽象类能使用 final 修饰吗？ 不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类\n创建一个对象用什么关键字？对象实例与对象引用有何不同？ new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）\n变量与方法 成员变量与局部变量的区别有哪些 变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域\n成员变量：方法外部，类内部定义的变量\n局部变量：类的方法中的变量。\n成员变量和局部变量的区别\n作用域\n成员变量：针对整个类有效。\n局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)\n存储位置\n成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。\n局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。\n生命周期\n成员变量：随着对象的创建而存在，随着对象的消失而消失\n局部变量：当方法调用完，或者语句结束后，就自动释放。\n初始值\n成员变量：有默认初始值。\n局部变量：没有默认初始值，使用前必须赋值。\n使用原则\n在使用变量时需要遵循的原则为：就近原则\n首先在局部范围找，有就使用；接着在成员位置找。\n在Java中定义一个不做事且没有参数的构造方法的作用 Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。\n在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？ 帮助子类做初始化工作。\n一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？ 主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。\n构造方法有哪些特性？ 名字与类名相同；\n没有返回值，但不能用void声明构造函数；\n生成类的对象时自动执行，无需调用。\n静态变量和实例变量区别 静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。\n实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。\n静态变量与普通变量区别 static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。\n还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。\n静态方法和实例方法有何不同？ 静态方法和实例方法的区别主要体现在两个方面：\n 在外部调用静态方法时，可以使用\u0026quot;类名.方法名\u0026quot;的方式，也可以使用\u0026quot;对象名.方法名\u0026quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制  在一个静态方法内调用一个非静态成员为什么是非法的？ 由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。\n什么是方法的返回值？返回值的作用是什么？ 方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！\n内部类 什么是内部类？ 在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。\n内部类的分类有哪些 内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。\n静态内部类 定义在类内部的静态类，就是静态内部类。\npublic class Outer { private static int radius = 1; static class StaticInner { public void visit() { System.out.println(\u0026quot;visit outer static variable:\u0026quot; + radius); } } } 静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：\nOuter.StaticInner inner = new Outer.StaticInner(); inner.visit(); 成员内部类 定义在类内部，成员位置上的非静态类，就是成员内部类。\npublic class Outer { private static int radius = 1; private int count =2; class Inner { public void visit() { System.out.println(\u0026quot;visit outer static variable:\u0026quot; + radius); System.out.println(\u0026quot;visit outer variable:\u0026quot; + count); } } } 成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：\nOuter outer = new Outer(); Outer.Inner inner = outer.new Inner(); inner.visit(); 局部内部类 定义在方法中的内部类，就是局部内部类。\npublic class Outer { private int out_a = 1; private static int STATIC_b = 2; public void testFunctionClass(){ int inner_c =3; class Inner { private void fun(){ System.out.println(out_a); System.out.println(STATIC_b); System.out.println(inner_c); } } Inner inner = new Inner(); inner.fun(); } public static void testStaticFunctionClass(){ int d =3; class Inner { private void fun(){ // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量 System.out.println(STATIC_b); System.out.println(d); } } Inner inner = new Inner(); inner.fun(); } } 定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：\npublic static void testStaticFunctionClass(){ class Inner { } Inner inner = new Inner(); } 匿名内部类 匿名内部类就是没有名字的内部类，日常开发中使用的比较多。\npublic class Outer { private void test(final int i) { new Service() { public void method() { for (int j = 0; j \u0026lt; i; j++) { System.out.println(\u0026quot;匿名内部类\u0026quot; ); } } }.method(); } } //匿名内部类必须继承或实现一个已有的接口 interface Service{ void method(); } 除了没有名字，匿名内部类还有以下特点：\n 匿名内部类必须继承一个抽象类或者实现一个接口。 匿名内部类不能定义任何静态成员和静态方法。 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。  匿名内部类创建方式：\nnew 类/接口{ //匿名内部类实现部分 } 内部类的优点 我们为什么要使用内部类呢？因为它有以下优点：\n 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！ 内部类不为同一包的其他类所见，具有很好的封装性； 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。 匿名内部类可以很方便的定义回调。  内部类有哪些应用场景  一些多算法场合 解决一些非面向对象的语句块。 适当使用内部类，使得代码更加灵活和富有扩展性。 当某个类除了它的外部类，不再被其他的类使用时。  局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？ 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？\n先看这段代码：\npublic class Outer { void outMethod(){ final int a =10; class Inner { void innerMethod(){ System.out.println(a); } } } } 以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。\n内部类相关，看程序说出运行结果 public class Outer { private int age = 12; class Inner { private int age = 13; public void print() { int age = 14; System.out.println(\u0026quot;局部变量：\u0026quot; + age); System.out.println(\u0026quot;内部类变量：\u0026quot; + this.age); System.out.println(\u0026quot;外部类变量：\u0026quot; + Outer.this.age); } } public static void main(String[] args) { Outer.Inner in = new Outer().new Inner(); in.print(); } } 运行结果：\n局部变量：14 内部类变量：13 外部类变量：12 重写与重载 构造器（constructor）是否可被重写（override） 构造器不能被继承，因此不能被重写，但可以被重载。\n重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。\n重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分\n重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。\n对象相等判断 == 和 equals 的区别是什么 == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)\nequals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。\n举个例子：\npublic class test1 { public static void main(String[] args) { String a = new String(\u0026quot;ab\u0026quot;); // a 为一个引用 String b = new String(\u0026quot;ab\u0026quot;); // b为另一个引用,对象的内容一样 String aa = \u0026quot;ab\u0026quot;; // 放在常量池中 String bb = \u0026quot;ab\u0026quot;; // 从常量池中查找 if (aa == bb) // true System.out.println(\u0026quot;aa==bb\u0026quot;); if (a == b) // false，非同一对象 System.out.println(\u0026quot;a==b\u0026quot;); if (a.equals(b)) // true System.out.println(\u0026quot;aEQb\u0026quot;); if (42 == 42.0) { // true System.out.println(\u0026quot;true\u0026quot;); } } } 说明：\n String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。  hashCode 与 equals (重要) HashSet如何检查重复\n两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？\nhashCode和equals方法的关系\n面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”\nhashCode()介绍\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n为什么要有 hashCode\n我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：\n当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\nhashCode()与equals()的相关规定\n如果两个对象相等，则hashcode一定也是相同的\n两个对象相等，对两个对象分别调用equals方法都返回true\n两个对象有相同的hashcode值，它们也不一定是相等的\n因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖\nhashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n对象的相等与指向他们的引用相等，两者有什么不同？ 对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。\n值传递 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递 是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的\n为什么 Java 中只有值传递 首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。\nJava程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。\n下面通过 3 个例子来给大家说明\nexample 1\npublic static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\u0026quot;num1 = \u0026quot; + num1); System.out.println(\u0026quot;num2 = \u0026quot; + num2); } public static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(\u0026quot;a = \u0026quot; + a); System.out.println(\u0026quot;b = \u0026quot; + b); } 结果：\na = 20 b = 10 num1 = 10 num2 = 20 在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.\nexample 2\npublic static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]); } public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0; } 结果：\n1 0 解析：\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。\n很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。\nexample 3\npublic class Test { public static void main(String[] args) { // TODO Auto-generated method stub Student s1 = new Student(\u0026quot;小张\u0026quot;); Student s2 = new Student(\u0026quot;小李\u0026quot;); Test.swap(s1, s2); System.out.println(\u0026quot;s1:\u0026quot; + s1.getName()); System.out.println(\u0026quot;s2:\u0026quot; + s2.getName()); } public static void swap(Student x, Student y) { Student temp = x; x = y; y = temp; System.out.println(\u0026quot;x:\u0026quot; + x.getName()); System.out.println(\u0026quot;y:\u0026quot; + y.getName()); } } 结果：\nx:小李 y:小张 s1:小张 s2:小李 解析：\n交换之前：\n交换之后：\n通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝\n总结\nJava程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。\n下面再总结一下Java中方法参数的使用情况：\n 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。  值传递和引用传递有什么区别 值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。\nJava包 JDK 中常用的包有哪些  java.lang：这个是系统的基础类； java.io：这里面是所有输入输出有关的类，比如文件操作等； java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包； java.net：这里面是与网络有关的类； java.util：这个是系统辅助类，特别是集合类； java.sql：这个是数据库操作的类。  import java和javax有什么区别 刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。\n所以，实际上java和javax没有区别。这都是一个名字。\nIO流 java 中 IO 流分为几种?  按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。  Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。\n InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。  按操作方式分类结构图：\n按操作对象分类结构图：\nBIO,NIO,AIO 有什么区别? 简答\n BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。  详细回答\n BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发 AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。  Files的常用方法都有哪些？  Files. exists()：检测文件路径是否存在。 Files. createFile()：创建文件。 Files. createDirectory()：创建文件夹。 Files. delete()：删除一个文件或目录。 Files. copy()：复制文件。 Files. move()：移动文件。 Files. size()：查看文件个数。 Files. read()：读取文件。 Files. write()：写入文件。  反射 什么是反射机制？ JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n静态编译和动态编译\n **静态编译：**在编译时确定类型，绑定对象 **动态编译：**运行时确定类型，绑定对象  反射机制优缺点  优点： 运行期类型的判断，动态加载类，提高代码灵活度。 缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。  反射机制的应用场景有哪些？ 反射是框架设计的灵魂。\n在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。\n举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性\nJava获取反射的三种方法 1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制\npublic class Student { private int id; String name; protected boolean sex; public float score; } public class Get { //获取反射机制三种方式 public static void main(String[] args) throws ClassNotFoundException { //方式一(通过建立对象) Student stu = new Student(); Class classobj1 = stu.getClass(); System.out.println(classobj1.getName()); //方式二（所在通过路径-相对路径） Class classobj2 = Class.forName(\u0026quot;fanshe.Student\u0026quot;); System.out.println(classobj2.getName()); //方式三（通过类名） Class classobj3 = Student.class; System.out.println(classobj3.getName()); } } 常用API String相关 字符型常量和字符串常量的区别  形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)  什么是字符串常量池？ 字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。\nString 是最基本的数据类型吗 不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。\n这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’};\n但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。\nString有哪些特性  不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。 常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。 final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。  String为什么是不可变的吗？ 简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：\n/** The value is used for character storage. */ private final char value[]; String真的是不可变的吗？ 我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：\n1) String不可变但不代表引用不可以变\nString str = \u0026quot;Hello\u0026quot;; str = str + \u0026quot; World\u0026quot;; System.out.println(\u0026quot;str=\u0026quot; + str); str=Hello World 解析：\n实际上，原来String的内容是不变的，只是str由原来指向\u0026quot;Hello\u0026quot;的内存地址转为指向\u0026quot;Hello World\u0026quot;的内存地址而已，也就是说多开辟了一块内存区域给\u0026quot;Hello World\u0026quot;字符串。\n2) 通过反射是可以修改所谓的“不可变”对象\n// 创建字符串\u0026quot;Hello World\u0026quot;， 并赋给引用s String s = \u0026quot;Hello World\u0026quot;; System.out.println(\u0026quot;s = \u0026quot; + s); // Hello World // 获取String类中的value字段 Field valueFieldOfString = String.class.getDeclaredField(\u0026quot;value\u0026quot;); // 改变value属性的访问权限 valueFieldOfString.setAccessible(true); // 获取s对象上的value属性的值 char[] value = (char[]) valueFieldOfString.get(s); // 改变value所引用的数组中的第5个字符 value[5] = '_'; System.out.println(\u0026quot;s = \u0026quot; + s); // Hello_World 结果：\ns = Hello World s = Hello_World 解析：\n用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。\n是否可以继承 String 类 String 类是 final 类，不可以被继承。\nString str=\u0026ldquo;i\u0026quot;与 String str=new String(“i”)一样吗？ 不一样，因为内存的分配方式不一样。String str=\u0026ldquo;i\u0026quot;的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。\nString s = new String(“xyz”);创建了几个字符串对象 两个对象，一个是静态区的\u0026quot;xyz\u0026rdquo;，一个是用new创建在堆上的对象。\nString str1 = \u0026quot;hello\u0026quot;; //str1指向静态区 String str2 = new String(\u0026quot;hello\u0026quot;); //str2指向堆上的对象 String str3 = \u0026quot;hello\u0026quot;; String str4 = new String(\u0026quot;hello\u0026quot;); System.out.println(str1.equals(str2)); //true System.out.println(str2.equals(str4)); //true System.out.println(str1 == str3); //true System.out.println(str1 == str2); //false System.out.println(str2 == str4); //false System.out.println(str2 == \u0026quot;hello\u0026quot;); //false str2 = str1; System.out.println(str2 == \u0026quot;hello\u0026quot;); //true 如何将字符串反转？ 使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n示例代码：\n// StringBuffer reverse StringBuffer stringBuffer = new StringBuffer(); stringBuffer. append(\u0026quot;abcdefg\u0026quot;); System. out. println(stringBuffer. reverse()); // gfedcba // StringBuilder reverse StringBuilder stringBuilder = new StringBuilder(); stringBuilder. append(\u0026quot;abcdefg\u0026quot;); System. out. println(stringBuilder. reverse()); // gfedcba 数组有没有 length()方法？String 有没有 length()方法 数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。\nString 类的常用方法都有那些？  indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。  在使用 HashMap 的时候，用 String 做 key 有什么好处？ HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。\nString和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的 可变性\nString类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。\n线程安全性\nString中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。\n性能\n每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n对于三者使用的总结\n如果要操作少量的数据用 = String\n单线程操作字符串缓冲区 下操作大量数据 = StringBuilder\n多线程操作字符串缓冲区 下操作大量数据 = StringBuffer\nDate相关 包装类相关 自动装箱与拆箱 装箱：将基本类型用它们对应的引用类型包装起来；\n拆箱：将包装类型转换为基本数据类型；\nint 和 Integer 有什么区别 Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。\nJava 为每个原始类型提供了包装类型：\n原始类型: boolean，char，byte，short，int，long，float，double\n包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\nInteger a= 127 与 Integer b = 127相等吗 对于对象引用类型：==比较的是对象的内存地址。\n对于基本数据类型：==比较的是值。\n如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false\npublic static void main(String[] args) { Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 System.out.println(b == c); // true Integer a1 = 128; Integer b1 = 128; System.out.println(a1 == b1); // false Integer a2 = 127; Integer b2 = 127; System.out.println(a2 == b2); // true } ","permalink":"https://www.wilds.top/posts/dc554a88/","summary":"Java概述 何为编程 编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。\n为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。\n什么是Java Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。\njdk1.5之后的三大版本  Java SE（J2SE，Java 2 Platform Standard Edition，标准版） Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。 Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版） Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE Java ME（J2ME，Java 2 Platform Micro Edition，微型版） Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。  JVM、JRE和JDK的关系 JVM","title":"Java基础知识总结"},{"content":"  登录github账号，新建一个放图片的仓库\n  一般创建成功之后，会出现如下界面\n  下载并安装PicGo\n  去github获取token\n打开 Settings -\u0026gt; Developer settings -\u0026gt; Personal access tokens，最后点击 generate new token\ntoken 生成，注意它只会显示一次，所以你最好把它复制下来到你的备忘录存好，方便下次使用，否则下次有需要重新新建；\n  配置PicGo\n  加速访问\n直接访问github仓库的图片太慢了，所以我们用jsDelivr进行加速访问，直接在PicGo设置的自定义域名中设置\nhttps://cdn.jsdelivr.net/gh/用户名/仓库名上传之前最好对图片进行压缩，个人推荐TinyPNG。\n  ","permalink":"https://www.wilds.top/posts/584214c1/","summary":"  登录github账号，新建一个放图片的仓库\n  一般创建成功之后，会出现如下界面\n  下载并安装PicGo\n  去github获取token\n打开 Settings -\u0026gt; Developer settings -\u0026gt; Personal access tokens，最后点击 generate new token\ntoken 生成，注意它只会显示一次，所以你最好把它复制下来到你的备忘录存好，方便下次使用，否则下次有需要重新新建；\n  配置PicGo\n  加速访问\n直接访问github仓库的图片太慢了，所以我们用jsDelivr进行加速访问，直接在PicGo设置的自定义域名中设置\nhttps://cdn.jsdelivr.net/gh/用户名/仓库名上传之前最好对图片进行压缩，个人推荐TinyPNG。\n  ","title":"picgo+github搭建图床"},{"content":" 在磁盘管理分区，大小100G(随意大小)左右 去官网下载镜像，使用balenaEtcher将镜像写入U盘 调整win10的EFI分区大小为500MB（谨慎操作，建议删除分区后重建，然后用dism++恢复引导） bios进行相关设置，开机选择从U盘启动 进入安装页面，开始输入命令安装    连接WiFi\nitwctl device list station \u0026lt;devicename#一般是wlan0\u0026gt; scan station \u0026lt;devicename\u0026gt; get-networks station \u0026lt;devicename\u0026gt; connect \u0026lt;wifi名称\u0026gt; #如果知道devicename和WiFi名字,可以直接执行这一步 exit   设置国内源\nreflector -c China -a 6 --sort rate --save /etc/pacman.d/mirrorlist #使用reflector来获取速度最快的6个镜像并保存到mirrorlist文件中。或： nano /etc/pacman.d/mirrorlist #进入文件将第一个网址中间部分改为163,Ctrl+X保存#也可使用vim命令修改首先安装vim: pacman -S vim   磁盘准备\nlsblk #机械硬盘一般为sda，固态硬盘为nvme cfdisk /dev/nvme0n1 找到之前划分的空磁盘，选择new回车，输入大小回车，然后选择write回车，输入yes回车，最后选择quit回车退出 lsblk mkfs.ext4 /dev/nvme0n1p5 #将刚刚分好的区格式化为ext4格式   挂载分区\nmount /dev/nvme0n1p5 /mnt #上面新建的分区 lsblk #找到win10的EFI分区 mkdir /mnt/boot mount /dev/nvme0n1p2 /mnt/boot #挂载Win10的EFI分区   安装系统\npacstrap /mnt base linux linux-firmware nano #linux-firmware为默认内核，推荐使用linux-lts   生成fstab文件\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab cat /mnt/etc/fstab #检查生成的fstab是否正确（每个分区占一行）   配置新系统\narch-chroot /mnt timedatectl set-timezone Asia/Shanghai #设置时区 hwclock --systohc #同步硬件时钟 nano /etc/locale.gen Ctrl+W 输入 #en_US 回车 找到UTF-8那一行 删掉前面的#（取消注释） Ctrl+W 输入 #zh_CN 回车 找到UTF-8那一行 删掉前面的#（取消注释） Ctrl+X保存退出 locale-gen nano /etc/locale.conf 填入内容：LANG=en_US.UTF-8 nano /etc/hostname #创建并写入hostname，(arch) nano /etc/hosts #修改hosts(中间不是空格，而是tab) 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tarch.localdomain\tarch Ctrl+X保存退出 passwd #为root用户创建密码 pacman -S grub efibootmgr networkmanager network-manager-applet dialog wireless_tools wpa_supplicant os-prober mtools dosfstools ntfs-3g base-devel linux-headers reflector git sudo #安装基本的包，使用grub引导，命令比较长，不要输错 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch grub-mkconfig -o /boot/grub/grub.cfg exit umount -R /mnt reboot #拔出U盘   配置安装好的系统\nsystemctl start NetworkManager #启动服务 systemctl enable --now NetworkManager #开机自启动服务 nmcli device wifi list #连接WiFi nmcli device wifi connect wifi名 password wifi密码 useradd -m -G wheel -s /bin/bash username #创建普通用户 passwd username EDITOR=nano visudo Ctrl+W输入 # %wheel 回车找到这行,删除前面的#（取消注释） Ctrl+X保存退出   安装显卡驱动以及桌面\npacman -S xf86-video-intel(amdgpu) #集显驱动 pacman -S nvidia nvidia-utils #NVIDIA独显驱动 pacman -S xorg #安装显示服务器 pacman -S sddm #安装kde桌面环境 systemctl enable sddm #开机启动 pacman -S plasma kde-applications packagekit-qt5 #桌面环境 pacman -S ttf-sarasa-gothic #安装字体：更纱黑体 reboot   开机即可进入桌面环境了  ","permalink":"https://www.wilds.top/posts/307d4fd8/","summary":"在磁盘管理分区，大小100G(随意大小)左右 去官网下载镜像，使用balenaEtcher将镜像写入U盘 调整win10的EFI分区大小为500MB（谨慎操作，建议删除分区后重建，然后用dism++恢复引导） bios进行相关设置，开机选择从U盘启动 进入安装页面，开始输入命令安装    连接WiFi\nitwctl device list station \u0026lt;devicename#一般是wlan0\u0026gt; scan station \u0026lt;devicename\u0026gt; get-networks station \u0026lt;devicename\u0026gt; connect \u0026lt;wifi名称\u0026gt; #如果知道devicename和WiFi名字,可以直接执行这一步 exit   设置国内源\nreflector -c China -a 6 --sort rate --save /etc/pacman.d/mirrorlist #使用reflector来获取速度最快的6个镜像并保存到mirrorlist文件中。或： nano /etc/pacman.d/mirrorlist #进入文件将第一个网址中间部分改为163,Ctrl+X保存#也可使用vim命令修改首先安装vim: pacman -S vim   磁盘准备\nlsblk #机械硬盘一般为sda，固态硬盘为nvme cfdisk /dev/nvme0n1 找到之前划分的空磁盘，选择new回车，输入大小回车，然后选择write回车，输入yes回车，最后选择quit回车退出 lsblk mkfs.ext4 /dev/nvme0n1p5 #将刚刚分好的区格式化为ext4格式   挂载分区\nmount /dev/nvme0n1p5 /mnt #上面新建的分区 lsblk #找到win10的EFI分区 mkdir /mnt/boot mount /dev/nvme0n1p2 /mnt/boot #挂载Win10的EFI分区   安装系统","title":"ArchLinux+Windows10双系统安装笔记"},{"content":"前言 使用github pages服务搭建博客的好处：\n 全是静态文件，访问速度快了； 免费，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器； 数据绝对安全，基于github的版本管理； 博客内容可以轻松打包、转移、发布到其它平台；  准备环境 首先安装Node.js®\n安装过程直接点next就行，有需要的可以改一下安装位置。\n安装Git\n安装过程同上。\n在安装完 Git 和 Node.js 后在任意文件夹右键打开 Git bash here 即可打开 Git 的 Bash 终端\n然后在git终端输入以下命令，查看查看 git 和 npm 版本号：\ngit --version\rNPM -v\r如果你的配置没问题，就会得到如下运行结果：\n安装hexo 完成上面操作后，就可以安装hexo了，也可查看hexo官方文档。\n在Git Bash 里执行以下命令：\nnpm install -g hexo-cli\rhexo安装完成后，在想要存储 hexo 文件的目录打开 Git Bash，然后初始化hexo，比如我想要在 D 盘的一个名为 hexo 的文件夹进行写作，那我在 D 盘打开 Git Bash 使用下面的命令初始化 Hexo 博客：\nhexo init hexo\r新建完成后，指定的文件夹目录如下：\n.\r├── _config.yml # Hexo的全局配置文件，在此配置网站的主要参数\r├── package.json # npm软件包以及版本信息\r├── scaffolds # 模版文件夹\r├── source # 资源文件夹\r| ├── _drafts # 草稿/模板文件\r| └── _posts # 文章Markdowm文件 └── themes # 主题文件夹\r然后安装一些组件\nnpm install\r安装好后，执行以下命令\nhexo g #generate 生成静态文件\rhexo s #server 启动服务器。\r默认情况下，访问网址为： http://localhost:4000/，打开网址，页码如下图：\n如果上面 hexo s 没有成功，可能是本地的 4000 端口被占用，请使用 hexo s -p 端口号 修改本地预览的端口号，然后打开浏览器，输入 http://localhost:你的端口号来启动本地预览.\n至此，你的本地博客已经搭建成功，接下来是部署到Github Page。\n关联Github 首先注册一个github账号（如何注册这里就不说了）\n登录到github，新建一个名为 username.github.io的公开仓库（私有仓库不能访问）其中username 是你的 github 用户名，例如我的用户名是 Test，那么我新建的仓库名称即为Test.github.io\n链接github与本地\n打开Git Bash，输入以下命令：\ngit config --global user.name \u0026quot;username\u0026quot; # username是你的Github用户名，注意大小写保持一致\rgit config --global user.email \u0026quot;your email address\u0026quot; # your email address填写你的Github注册用的邮箱\rssh-keygen -t rsa -C \u0026quot;your email address\u0026quot; # 生成SSH公钥，your email address同上填\r完成上面步骤后默认生成的密钥在 C:\\Users\\用户名\\.ssh\\ 目录下，以文本编辑器打开 id_rsa.pub 文件，复制里面的所有内容，后面会用到\n在github页面点击头像打开setting\n选择 SSH and GPG Keys，点击 New SSH Key\nTitle随便填，Key填你在本地id_rsa.pub文件中复制的所有内容\n打开 Git Bash，输入以下命令:\nssh -T git@github.com\r出现图中的提示代表成功了：(Hi 用户名！You’ve successfully authenticated，but……)\n打开 hexo 目录下的_config.yml 文件，修改最后一行的 deploy 配置信息：\ndeploy:\rtype: git\rrepo:\rgithub: https://github.com/username/username.github.io.git # 将username修改成你的Github用户名\rbranch: master 打开 Git Bash，输入如下命令：\nnpm install hexo-deployer-git --save\r推送到github仓库\nhexo clean \u0026amp;\u0026amp; hexo g \u0026amp;\u0026amp; hexo d\r如果前面没有出错的话，再次执行上面命令，你发现 hexo d 后本地预览的博客已经推送到你的远程仓库了，并且浏览器地址输入username.github.io 可以访问你的博客了，代表关联 Hexo 到 Github 成功了！\nhexo的命令极简单，安装后只需要记住四个常用的基础命令即可。执行命令需要git当前处于blog文件夹根目下\nhexo g #generate 生成静态文件\rhexo s #server 启动服务器。在本地预览效果，默认情况下，访问网址为： http://localhost:4000/\rhexo d #deploy 部署网站同步到github。部署网站前，需要预先生成静态文件\rhexo clean #clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。\rhexo高级配置 hexo有许多主题，目前大多数人使用next主题，本站使用的butterfly主题，安装过程如下：\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\r安装完还需要修改hexo的配置文件_config.yml:\ntheme: landscape # 默认的主题\rtheme: 修改为你的主题名\r个人推荐主题\n butterfly 详细设置可以看butterfly官方文档 fluid 详细设置可以看官方文档Fluid  插件推荐\n 压缩生成文件hexo-all-minifier 生成文章永久链接hexo-abbrlink 看板娘hexo-helper-live2d  ","permalink":"https://www.wilds.top/posts/1797fdb5/","summary":"前言 使用github pages服务搭建博客的好处：\n 全是静态文件，访问速度快了； 免费，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器； 数据绝对安全，基于github的版本管理； 博客内容可以轻松打包、转移、发布到其它平台；  准备环境 首先安装Node.js®\n安装过程直接点next就行，有需要的可以改一下安装位置。\n安装Git\n安装过程同上。\n在安装完 Git 和 Node.js 后在任意文件夹右键打开 Git bash here 即可打开 Git 的 Bash 终端\n然后在git终端输入以下命令，查看查看 git 和 npm 版本号：\ngit --version\rNPM -v\r如果你的配置没问题，就会得到如下运行结果：\n安装hexo 完成上面操作后，就可以安装hexo了，也可查看hexo官方文档。\n在Git Bash 里执行以下命令：\nnpm install -g hexo-cli\rhexo安装完成后，在想要存储 hexo 文件的目录打开 Git Bash，然后初始化hexo，比如我想要在 D 盘的一个名为 hexo 的文件夹进行写作，那我在 D 盘打开 Git Bash 使用下面的命令初始化 Hexo 博客：\nhexo init hexo\r新建完成后，指定的文件夹目录如下：\n.\r├── _config.yml # Hexo的全局配置文件，在此配置网站的主要参数\r├── package.","title":"Hexo+Github 搭建博客"},{"content":".friends { padding: 1em 0; border: 2px solid transparent; border-bottom: 1px dashed var(--color-contrast-low); display: flex; transition: all .5s; } .friends .friend { text-decoration: none; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .friends .name { font-weight: bold; margin: 0.375em 0; } .friends .excerpt { font-size: 0.875em; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .friends .avatar { width: 4em !important; height: 4em !important; margin: 0 1em 0 0 !important; z-index: 0; }  AimerNeige\u0026#39;s Blog 技术宅拯救世界    OneDriveShare 个人网盘    陶辉的博客 陶辉的技术分享    ","permalink":"https://www.wilds.top/friends/","summary":".friends { padding: 1em 0; border: 2px solid transparent; border-bottom: 1px dashed var(--color-contrast-low); display: flex; transition: all .5s; } .friends .friend { text-decoration: none; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .friends .name { font-weight: bold; margin: 0.375em 0; } .friends .excerpt { font-size: 0.875em; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } .friends .avatar { width: 4em !important; height: 4em !important; margin: 0 1em 0 0 !important; z-index: 0; }  AimerNeige\u0026#39;s Blog 技术宅拯救世界    OneDriveShare 个人网盘    陶辉的博客 陶辉的技术分享    ","title":"Friends 👋"}]