<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Lambda表达式 | Earlのblog</title>
<meta name=keywords content="Java">
<meta name=description content="Lambda常见用法">
<meta name=author content>
<link rel=canonical href=https://blog.addxe.com/posts/ff79dbf8/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.a1a1073ca47c48aad5c688a1c98be56e6c93d809db1f643397d7fbc03356fe0f.css integrity="sha256-oaEHPKR8SKrVxoihyYvlbmyT2AnbH2Qzl9f7wDNW/g8=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.addxe.com/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.addxe.com/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.addxe.com/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.addxe.com/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.addxe.com/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><style type=text/css>@font-face{font-family:myFont;src:url(https://static.addxe.com/static/font/yuan.woff)}</style>
<link rel=stylesheet href=https://static.addxe.com/static/js/highlight.min.js>
<script src=https://static.addxe.com/static/css/androidstudio.min.css></script>
<script>hljs.highlightAll()</script>
<script>var _paq=window._paq=window._paq||[];_paq.push(['trackPageView']),_paq.push(['enableLinkTracking']),function(){var b="//mo.addxe.com/",c,a,d;_paq.push(['setTrackerUrl',b+'matomo.php']),_paq.push(['setSiteId','2']),c=document,a=c.createElement('script'),d=c.getElementsByTagName('script')[0],a.async=!0,a.src=b+'matomo.js',d.parentNode.insertBefore(a,d)}()</script>
<style>body{font-family:myFont,DFPHannotateW5-GB,SimHei,-apple-system,BlinkMacSystemFont,YouYuan,NSimSun,Yuanti SC,KaiTi,open sans,PingFang SC,sans-serif;font-size:19px}code{font-family:myFont,DFPHannotateW5-GB,SimHei,DFPHannotateW5-GB,-apple-system,BlinkMacSystemFont,YouYuan,NSimSun,KaiTi,Yuanti SC,Yuanti SC,open sans,sans-serif}</style>
<link rel=stylesheet href=https://static.addxe.com/static/font-awesome-4.7.0/css/font-awesome.min.css>
<meta property="og:title" content="Lambda表达式">
<meta property="og:description" content="Lambda常见用法">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.addxe.com/posts/ff79dbf8/"><meta property="og:image" content="https://blog.addxe.com/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-08T22:57:16+08:00">
<meta property="article:modified_time" content="2021-11-08T22:57:16+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.addxe.com/papermod-cover.png">
<meta name=twitter:title content="Lambda表达式">
<meta name=twitter:description content="Lambda常见用法">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.addxe.com/posts/"},{"@type":"ListItem","position":2,"name":"Lambda表达式","item":"https://blog.addxe.com/posts/ff79dbf8/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lambda表达式","name":"Lambda表达式","description":"Lambda常见用法","keywords":["Java"],"articleBody":"Lambda简介 Lambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。\nJDK 也提供了大量的内置函数式接口供我们使用，使得 Lambda 表达式的运用更加方便、高效。\n对接口的要求 虽然使用 Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。Lambda 规定接口中只能有一个需要被实现的方法，不是规定接口中只能有一个方法\n jdk 8 中有另一个新特性：default， 被 default 修饰的方法会有默认实现，不是必须被实现的方法，所以不影响 Lambda 表达式的使用。\n @FunctionalInterface 修饰函数式接口的，要求接口中的抽象方法只有一个。 这个注解往往会和 lambda 表达式一起出现。\nLambda 基础语法 我们这里给出六个接口，后文的全部操作都利用这六个接口来进行阐述。\n/**多参数无返回*/ @FunctionalInterface public interface NoReturnMultiParam { void method(int a, int b); } /**无参无返回值*/ @FunctionalInterface public interface NoReturnNoParam { void method(); } /**一个参数无返回*/ @FunctionalInterface public interface NoReturnOneParam { void method(int a); } /**多个参数有返回值*/ @FunctionalInterface public interface ReturnMultiParam { int method(int a, int b); } /*** 无参有返回*/ @FunctionalInterface public interface ReturnNoParam { int method(); } /**一个参数有返回值*/ @FunctionalInterface public interface ReturnOneParam { int method(int a); } Lambda语法由三部分组成：() - {}\n参数块：就是前面的 ()，就是简单地把要实现的抽象方法的参数原封不动写在这。\n小箭头：就是 - 这个符号。\n代码块：就是{}要实现的方法原封不动写在这。\nimport lambda.interfaces.*; public class Test { public static void main(String[] args) { //无参无返回  NoReturnNoParam noReturnNoParam = () - { System.out.println(\"无参无返回\"); }; noReturnNoParam.method(); //一个参数无返回  NoReturnOneParam noReturnOneParam = (int a) - { System.out.println(\"一个参数无返回:\" + a); }; noReturnOneParam.method(6); //多个参数无返回  NoReturnMultiParam noReturnMultiParam = (int a, int b) - { System.out.println(\"多个参数无返回:\" + \"{\" + a +\",\" + + b +\"}\"); }; noReturnMultiParam.method(6, 8); //无参有返回值  ReturnNoParam returnNoParam = () - { System.out.print(\"无参有返回值\"); return 1; }; int res = returnNoParam.method(); System.out.println(\"return:\" + res); //一个参数有返回值  ReturnOneParam returnOneParam = (int a) - { System.out.println(\"一个参数有返回值:\" + a); return 1; }; int res2 = returnOneParam.method(6); System.out.println(\"return:\" + res2); //多个参数有返回值  ReturnMultiParam returnMultiParam = (int a, int b) - { System.out.println(\"多个参数有返回值:\" + \"{\" + a + \",\" + b +\"}\"); return 1; }; int res3 = returnMultiParam.method(6, 8); System.out.println(\"return:\" + res3); } } Lambda 语法简化 我们可以通过观察以下代码来完成代码的进一步简化，写出更加优雅的代码。\nimport lambda.interfaces.*; public class Test { public static void main(String[] args) { //1.简化参数类型，可以不写参数类型，但是必须所有参数都不写  NoReturnMultiParam lamdba1 = (a, b) - { System.out.println(\"简化参数类型\"); }; lamdba1.method(1, 2); //2.简化参数小括号，如果只有一个参数则可以省略参数小括号  NoReturnOneParam lambda2 = a - { System.out.println(\"简化参数小括号\"); }; lambda2.method(1); //3.简化方法体大括号，如果方法条只有一条语句，则可以胜率方法体大括号  NoReturnNoParam lambda3 = () - System.out.println(\"简化方法体大括号\"); lambda3.method(); //4.如果方法体只有一条语句，并且是 return 语句，则可以省略方法体大括号  ReturnOneParam lambda4 = a - a+3; System.out.println(lambda4.method(5)); ReturnMultiParam lambda5 = (a, b) - a+b; System.out.println(lambda5.method(1, 1)); } } Lambda 表达式常用示例  lambda 表达式引用方法  有时候我们不是必须要自己重写某个匿名内部类的方法，我们可以可以利用 lambda表达式的接口快速指向一个已经被实现的方法。\n语法\n方法归属者::方法名 静态方法的归属者为类名，普通方法归属者为对象\npublic class Exe1 { public static void main(String[] args) { ReturnOneParam lambda1 = a - doubleNum(a); System.out.println(lambda1.method(3)); //lambda2 引用了已经实现的 doubleNum 方法  ReturnOneParam lambda2 = Exe1::doubleNum; System.out.println(lambda2.method(3)); Exe1 exe = new Exe1(); //lambda4 引用了已经实现的 addTwo 方法  ReturnOneParam lambda4 = exe::addTwo; System.out.println(lambda4.method(2)); } /** * 要求 * 1.参数数量和类型要与接口中定义的一致 * 2.返回值类型要与接口中定义的一致 */ public static int doubleNum(int a) { return a * 2; } public int addTwo(int a) { return a + 2; } }  构造方法的引用  一般我们需要声明接口，该接口作为对象的生成器，通过 类名::new 的方式来实例化对象，然后调用方法返回对象。\ninterface ItemCreatorBlankConstruct { Item getItem(); } interface ItemCreatorParamContruct { Item getItem(int id, String name, double price); } public class Exe2 { public static void main(String[] args) { ItemCreatorBlankConstruct creator = () - new Item(); Item item = creator.getItem(); ItemCreatorBlankConstruct creator2 = Item::new; Item item2 = creator2.getItem(); ItemCreatorParamContruct creator3 = Item::new; Item item3 = creator3.getItem(112, \"鼠标\", 135.99); } }  lambda 表达式创建线程  我们以往都是通过创建 Thread 对象，然后通过匿名内部类重写 run() 方法，一提到匿名内部类我们就应该想到可以使用 lambda 表达式来简化线程的创建过程。\nThread t = new Thread(() - { for (int i = 0; i  10; i++) { System.out.println(2 + \":\" + i); } }); t.start();  遍历集合  我们可以调用集合的 public void forEach(Consumeraction) 方法，通过 lambda 表达式的方式遍历集合中的元素。以下是 Consumer 接口的方法以及遍历集合的操作。Consumer 接口是 jdk 为我们提供的一个函数式接口。\n@FunctionalInterface public interface ConsumerT { void accept(T t); //....  } Copy ArrayListInteger list = new ArrayList(); Collections.addAll(list, 1,2,3,4,5); //lambda表达式 方法引用  list.forEach(System.out::println); list.forEach(element - { if (element % 2 == 0) { System.out.println(element); } });  删除集合中的某个元素  我们通过public boolean removeIf(Predicatefilter)方法来删除集合中的某个元素，Predicate 也是 jdk 为我们提供的一个函数式接口，可以简化程序的编写。\nArrayListItem items = new ArrayList(); items.add(new Item(11, \"小牙刷\", 12.05 )); items.add(new Item(5, \"日本马桶盖\", 999.05 )); items.add(new Item(7, \"格力空调\", 888.88 )); items.add(new Item(17, \"肥皂\", 2.00 )); items.add(new Item(9, \"冰箱\", 4200.00 )); items.removeIf(ele - ele.getId() == 7); //通过 foreach 遍历，查看是否已经删除  items.forEach(System.out::println);  集合内元素的排序  在以前我们若要为集合内的元素排序，就必须调用 sort 方法，传入比较器匿名内部类重写 compare 方法，我们现在可以使用 lambda 表达式来简化代码。\nArrayListItem list = new ArrayList(); list.add(new Item(13, \"背心\", 7.80)); list.add(new Item(11, \"半袖\", 37.80)); list.add(new Item(14, \"风衣\", 139.80)); list.add(new Item(12, \"秋裤\", 55.33)); /* list.sort(new Comparator() { @Override public int compare(Item o1, Item o2) { return o1.getId() - o2.getId(); } }); */ list.sort((o1, o2) - o1.getId() - o2.getId()); System.out.println(list); Lambda 表达式中的闭包问题 这个问题我们在匿名内部类中也会存在，如果我们把注释放开会报错，告诉我 num 值是 final 不能被改变。这里我们虽然没有标识 num 类型为 final，但是在编译期间虚拟机会帮我们加上 final 修饰关键字。\nimport java.util.function.Consumer; public class Main { public static void main(String[] args) { int num = 10; ConsumerString consumer = ele - { System.out.println(num); }; //num = num + 2;  consumer.accept(\"hello\"); } } 总结 学会理解和写 Lambda 表达式的三步:\n1. 确认 Lambda 表达式的类型:\n 能用 Lambda 表达式来表示的类型，必须是一个函数式接口，而函数式接口，就是只有一个抽象方法的接口。  2. 找到要实现的方法:\n Lambda 表达式就是实现一个方法，什么方法呢？就是刚刚那些函数式接口中的抽象方法  3. 实现这个方法:\n Lambda 表达式就是要实现这个抽象方法，如果不用 Lambda 表达式，你一定知道用匿名类如何去实现  Lambda 表达式的类型就是函数式接口，要实现的方法就是函数式接口里那个唯一的抽象方法，实现这个方法的方式就是参数块 + 小箭头 + 方法体，其中参数块和方法体都可以一定程度上简化它的写法。\n","wordCount":"703","inLanguage":"en","datePublished":"2021-11-08T22:57:16+08:00","dateModified":"2021-11-08T22:57:16+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.addxe.com/posts/ff79dbf8/"},"publisher":{"@type":"Organization","name":"Earlのblog","logo":{"@type":"ImageObject","url":"https://blog.addxe.com/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.addxe.com/ accesskey=h title="Earlのblog (Alt + H)">Earlのblog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.addxe.com/search title>
<span><i class="fa fa-search"></i></span>
</a>
</li>
<li>
<a href=https://blog.addxe.com/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://blog.addxe.com/categories title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://blog.addxe.com/tags title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://blog.addxe.com/friends/ title=Friends>
<span>Friends</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://blog.addxe.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.addxe.com/posts/>Posts</a></div>
<h1 class=post-title>
Lambda表达式
</h1>
<div class=post-description>
Lambda常见用法
</div>
<div class=post-meta><span title="2021-11-08 22:57:16 +0800 CST">November 8, 2021</span>&nbsp;·&nbsp;4 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#lambda%e7%ae%80%e4%bb%8b aria-label=Lambda简介>Lambda简介</a></li>
<li>
<a href=#%e5%af%b9%e6%8e%a5%e5%8f%a3%e7%9a%84%e8%a6%81%e6%b1%82 aria-label=对接口的要求>对接口的要求</a></li>
<li>
<a href=#functionalinterface aria-label=@FunctionalInterface>@FunctionalInterface</a></li>
<li>
<a href=#lambda-%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95 aria-label="Lambda 基础语法">Lambda 基础语法</a></li>
<li>
<a href=#lambda-%e8%af%ad%e6%b3%95%e7%ae%80%e5%8c%96 aria-label="Lambda 语法简化">Lambda 语法简化</a></li>
<li>
<a href=#lambda-%e8%a1%a8%e8%be%be%e5%bc%8f%e5%b8%b8%e7%94%a8%e7%a4%ba%e4%be%8b aria-label="Lambda 表达式常用示例">Lambda 表达式常用示例</a></li>
<li>
<a href=#lambda-%e8%a1%a8%e8%be%be%e5%bc%8f%e4%b8%ad%e7%9a%84%e9%97%ad%e5%8c%85%e9%97%ae%e9%a2%98 aria-label="Lambda 表达式中的闭包问题">Lambda 表达式中的闭包问题</a></li>
<li>
<a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h3 id=lambda简介>Lambda简介<a hidden class=anchor aria-hidden=true href=#lambda简介>#</a></h3>
<p>Lambda 表达式是 JDK8 的一个新特性，可以取代大部分的匿名内部类，写出更优雅的 Java 代码，尤其在集合的遍历和其他集合操作中，可以极大地优化代码结构。</p>
<p>JDK 也提供了大量的内置函数式接口供我们使用，使得 Lambda 表达式的运用更加方便、高效。</p>
<h3 id=对接口的要求>对接口的要求<a hidden class=anchor aria-hidden=true href=#对接口的要求>#</a></h3>
<p>虽然使用 Lambda 表达式可以对某些接口进行简单的实现，但并不是所有的接口都可以使用 Lambda 表达式来实现。<strong>Lambda 规定接口中只能有一个需要被实现的方法，不是规定接口中只能有一个方法</strong></p>
<blockquote>
<p>jdk 8 中有另一个新特性：default， 被 default 修饰的方法会有默认实现，不是必须被实现的方法，所以不影响 Lambda 表达式的使用。</p>
</blockquote>
<h3 id=functionalinterface>@FunctionalInterface<a hidden class=anchor aria-hidden=true href=#functionalinterface>#</a></h3>
<p>修饰函数式接口的，要求接口中的抽象方法只有一个。 这个注解往往会和 lambda 表达式一起出现。</p>
<h3 id=lambda-基础语法>Lambda 基础语法<a hidden class=anchor aria-hidden=true href=#lambda-基础语法>#</a></h3>
<p>我们这里给出六个接口，后文的全部操作都利用这六个接口来进行阐述。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**多参数无返回*/</span>
<span class=nd>@FunctionalInterface</span>
<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>NoReturnMultiParam</span> <span class=o>{</span>
    <span class=kt>void</span> <span class=nf>method</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>);</span>
<span class=o>}</span>

<span class=cm>/**无参无返回值*/</span>
<span class=nd>@FunctionalInterface</span>
<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>NoReturnNoParam</span> <span class=o>{</span>
    <span class=kt>void</span> <span class=nf>method</span><span class=o>();</span>
<span class=o>}</span>

<span class=cm>/**一个参数无返回*/</span>
<span class=nd>@FunctionalInterface</span>
<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>NoReturnOneParam</span> <span class=o>{</span>
    <span class=kt>void</span> <span class=nf>method</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>);</span>
<span class=o>}</span>

<span class=cm>/**多个参数有返回值*/</span>
<span class=nd>@FunctionalInterface</span>
<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>ReturnMultiParam</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=nf>method</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>);</span>
<span class=o>}</span>

<span class=cm>/*** 无参有返回*/</span>
<span class=nd>@FunctionalInterface</span>
<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>ReturnNoParam</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=nf>method</span><span class=o>();</span>
<span class=o>}</span>

<span class=cm>/**一个参数有返回值*/</span>
<span class=nd>@FunctionalInterface</span>
<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>ReturnOneParam</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=nf>method</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>);</span>
<span class=o>}</span>
</code></pre></div><p>Lambda语法由三部分组成：() -> {}</p>
<p><strong>参数块</strong>：就是前面的 ()，就是简单地把要实现的抽象方法的参数原封不动写在这。</p>
<p><strong>小箭头</strong>：就是 -> 这个符号。</p>
<p><strong>代码块</strong>：就是{}要实现的方法原封不动写在这。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kn>import</span> <span class=nn>lambda.interfaces.*</span><span class=o>;</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>

        <span class=c1>//无参无返回
</span><span class=c1></span>        <span class=n>NoReturnNoParam</span> <span class=n>noReturnNoParam</span> <span class=o>=</span> <span class=o>()</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;无参无返回&#34;</span><span class=o>);</span>
        <span class=o>};</span>
        <span class=n>noReturnNoParam</span><span class=o>.</span><span class=na>method</span><span class=o>();</span>

        <span class=c1>//一个参数无返回
</span><span class=c1></span>        <span class=n>NoReturnOneParam</span> <span class=n>noReturnOneParam</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;一个参数无返回:&#34;</span> <span class=o>+</span> <span class=n>a</span><span class=o>);</span>
        <span class=o>};</span>
        <span class=n>noReturnOneParam</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>6</span><span class=o>);</span>

        <span class=c1>//多个参数无返回
</span><span class=c1></span>        <span class=n>NoReturnMultiParam</span> <span class=n>noReturnMultiParam</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;多个参数无返回:&#34;</span> <span class=o>+</span> <span class=s>&#34;{&#34;</span> <span class=o>+</span> <span class=n>a</span> <span class=o>+</span><span class=s>&#34;,&#34;</span> <span class=o>+</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span><span class=s>&#34;}&#34;</span><span class=o>);</span>
        <span class=o>};</span>
        <span class=n>noReturnMultiParam</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>6</span><span class=o>,</span> <span class=n>8</span><span class=o>);</span>

        <span class=c1>//无参有返回值
</span><span class=c1></span>        <span class=n>ReturnNoParam</span> <span class=n>returnNoParam</span> <span class=o>=</span> <span class=o>()</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=s>&#34;无参有返回值&#34;</span><span class=o>);</span>
            <span class=k>return</span> <span class=n>1</span><span class=o>;</span>
        <span class=o>};</span>

        <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=n>returnNoParam</span><span class=o>.</span><span class=na>method</span><span class=o>();</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;return:&#34;</span> <span class=o>+</span> <span class=n>res</span><span class=o>);</span>

        <span class=c1>//一个参数有返回值
</span><span class=c1></span>        <span class=n>ReturnOneParam</span> <span class=n>returnOneParam</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;一个参数有返回值:&#34;</span> <span class=o>+</span> <span class=n>a</span><span class=o>);</span>
            <span class=k>return</span> <span class=n>1</span><span class=o>;</span>
        <span class=o>};</span>

        <span class=kt>int</span> <span class=n>res2</span> <span class=o>=</span> <span class=n>returnOneParam</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>6</span><span class=o>);</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;return:&#34;</span> <span class=o>+</span> <span class=n>res2</span><span class=o>);</span>

        <span class=c1>//多个参数有返回值
</span><span class=c1></span>        <span class=n>ReturnMultiParam</span> <span class=n>returnMultiParam</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;多个参数有返回值:&#34;</span> <span class=o>+</span> <span class=s>&#34;{&#34;</span> <span class=o>+</span> <span class=n>a</span> <span class=o>+</span> <span class=s>&#34;,&#34;</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span><span class=s>&#34;}&#34;</span><span class=o>);</span>
            <span class=k>return</span> <span class=n>1</span><span class=o>;</span>
        <span class=o>};</span>

        <span class=kt>int</span> <span class=n>res3</span> <span class=o>=</span> <span class=n>returnMultiParam</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>6</span><span class=o>,</span> <span class=n>8</span><span class=o>);</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;return:&#34;</span> <span class=o>+</span> <span class=n>res3</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><h3 id=lambda-语法简化>Lambda 语法简化<a hidden class=anchor aria-hidden=true href=#lambda-语法简化>#</a></h3>
<p>我们可以通过观察以下代码来完成代码的进一步简化，写出更加优雅的代码。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kn>import</span> <span class=nn>lambda.interfaces.*</span><span class=o>;</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Test</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>

        <span class=c1>//1.简化参数类型，可以不写参数类型，但是必须所有参数都不写
</span><span class=c1></span>        <span class=n>NoReturnMultiParam</span> <span class=n>lamdba1</span> <span class=o>=</span> <span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;简化参数类型&#34;</span><span class=o>);</span>
        <span class=o>};</span>
        <span class=n>lamdba1</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>2</span><span class=o>);</span>

        <span class=c1>//2.简化参数小括号，如果只有一个参数则可以省略参数小括号
</span><span class=c1></span>        <span class=n>NoReturnOneParam</span> <span class=n>lambda2</span> <span class=o>=</span> <span class=n>a</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;简化参数小括号&#34;</span><span class=o>);</span>
        <span class=o>};</span>
        <span class=n>lambda2</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>

        <span class=c1>//3.简化方法体大括号，如果方法条只有一条语句，则可以胜率方法体大括号
</span><span class=c1></span>        <span class=n>NoReturnNoParam</span> <span class=n>lambda3</span> <span class=o>=</span> <span class=o>()</span> <span class=o>-&gt;</span> <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;简化方法体大括号&#34;</span><span class=o>);</span>
        <span class=n>lambda3</span><span class=o>.</span><span class=na>method</span><span class=o>();</span>

        <span class=c1>//4.如果方法体只有一条语句，并且是 return 语句，则可以省略方法体大括号
</span><span class=c1></span>        <span class=n>ReturnOneParam</span> <span class=n>lambda4</span> <span class=o>=</span> <span class=n>a</span> <span class=o>-&gt;</span> <span class=n>a</span><span class=o>+</span><span class=n>3</span><span class=o>;</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>lambda4</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>5</span><span class=o>));</span>

        <span class=n>ReturnMultiParam</span> <span class=n>lambda5</span> <span class=o>=</span> <span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=o>;</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>lambda5</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>1</span><span class=o>,</span> <span class=n>1</span><span class=o>));</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><h3 id=lambda-表达式常用示例>Lambda 表达式常用示例<a hidden class=anchor aria-hidden=true href=#lambda-表达式常用示例>#</a></h3>
<ul>
<li><strong>lambda 表达式引用方法</strong></li>
</ul>
<p>有时候我们不是必须要自己重写某个匿名内部类的方法，我们可以可以利用 lambda表达式的接口快速指向一个已经被实现的方法。</p>
<p><strong>语法</strong></p>
<p>方法归属者::方法名 静态方法的归属者为类名，普通方法归属者为对象</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Exe1</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>ReturnOneParam</span> <span class=n>lambda1</span> <span class=o>=</span> <span class=n>a</span> <span class=o>-&gt;</span> <span class=n>doubleNum</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>lambda1</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>3</span><span class=o>));</span>

        <span class=c1>//lambda2 引用了已经实现的 doubleNum 方法
</span><span class=c1></span>        <span class=n>ReturnOneParam</span> <span class=n>lambda2</span> <span class=o>=</span> <span class=n>Exe1</span><span class=o>::</span><span class=n>doubleNum</span><span class=o>;</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>lambda2</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>3</span><span class=o>));</span>

        <span class=n>Exe1</span> <span class=n>exe</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Exe1</span><span class=o>();</span>

        <span class=c1>//lambda4 引用了已经实现的 addTwo 方法
</span><span class=c1></span>        <span class=n>ReturnOneParam</span> <span class=n>lambda4</span> <span class=o>=</span> <span class=n>exe</span><span class=o>::</span><span class=n>addTwo</span><span class=o>;</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>lambda4</span><span class=o>.</span><span class=na>method</span><span class=o>(</span><span class=n>2</span><span class=o>));</span>
    <span class=o>}</span>

    <span class=cm>/**
</span><span class=cm>     * 要求
</span><span class=cm>     * 1.参数数量和类型要与接口中定义的一致
</span><span class=cm>     * 2.返回值类型要与接口中定义的一致
</span><span class=cm>     */</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>doubleNum</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>2</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>addTwo</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>2</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><ul>
<li><strong>构造方法的引用</strong></li>
</ul>
<p>一般我们需要声明接口，该接口作为对象的生成器，通过 类名::new 的方式来实例化对象，然后调用方法返回对象。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>interface</span> <span class=nc>ItemCreatorBlankConstruct</span> <span class=o>{</span>
    <span class=n>Item</span> <span class=nf>getItem</span><span class=o>();</span>
<span class=o>}</span>
<span class=kd>interface</span> <span class=nc>ItemCreatorParamContruct</span> <span class=o>{</span>
    <span class=n>Item</span> <span class=nf>getItem</span><span class=o>(</span><span class=kt>int</span> <span class=n>id</span><span class=o>,</span> <span class=n>String</span> <span class=n>name</span><span class=o>,</span> <span class=kt>double</span> <span class=n>price</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Exe2</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>ItemCreatorBlankConstruct</span> <span class=n>creator</span> <span class=o>=</span> <span class=o>()</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>Item</span><span class=o>();</span>
        <span class=n>Item</span> <span class=n>item</span> <span class=o>=</span> <span class=n>creator</span><span class=o>.</span><span class=na>getItem</span><span class=o>();</span>

        <span class=n>ItemCreatorBlankConstruct</span> <span class=n>creator2</span> <span class=o>=</span> <span class=n>Item</span><span class=o>::</span><span class=k>new</span><span class=o>;</span>
        <span class=n>Item</span> <span class=n>item2</span> <span class=o>=</span> <span class=n>creator2</span><span class=o>.</span><span class=na>getItem</span><span class=o>();</span>

        <span class=n>ItemCreatorParamContruct</span> <span class=n>creator3</span> <span class=o>=</span> <span class=n>Item</span><span class=o>::</span><span class=k>new</span><span class=o>;</span>
        <span class=n>Item</span> <span class=n>item3</span> <span class=o>=</span> <span class=n>creator3</span><span class=o>.</span><span class=na>getItem</span><span class=o>(</span><span class=n>112</span><span class=o>,</span> <span class=s>&#34;鼠标&#34;</span><span class=o>,</span> <span class=n>135</span><span class=o>.</span><span class=na>99</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><ul>
<li><strong>lambda 表达式创建线程</strong></li>
</ul>
<p>我们以往都是通过创建 Thread 对象，然后通过匿名内部类重写 run() 方法，一提到匿名内部类我们就应该想到可以使用 lambda 表达式来简化线程的创建过程。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java>    <span class=n>Thread</span> <span class=n>t</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Thread</span><span class=o>(()</span> <span class=o>-&gt;</span> <span class=o>{</span>
      <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>10</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>2</span> <span class=o>+</span> <span class=s>&#34;:&#34;</span> <span class=o>+</span> <span class=n>i</span><span class=o>);</span>
      <span class=o>}</span>
    <span class=o>});</span>
  	<span class=n>t</span><span class=o>.</span><span class=na>start</span><span class=o>();</span>
</code></pre></div><ul>
<li><strong>遍历集合</strong></li>
</ul>
<p>我们可以调用集合的 <code>public void forEach(Consumer&lt;? super E> action)</code> 方法，通过 lambda 表达式的方式遍历集合中的元素。以下是 Consumer 接口的方法以及遍历集合的操作。Consumer 接口是 jdk 为我们提供的一个函数式接口。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java>    <span class=nd>@FunctionalInterface</span>
    <span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Consumer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
        <span class=kt>void</span> <span class=nf>accept</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>);</span>
        <span class=c1>//....
</span><span class=c1></span>    <span class=o>}</span>
<span class=n>Copy</span>      <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>

      <span class=n>Collections</span><span class=o>.</span><span class=na>addAll</span><span class=o>(</span><span class=n>list</span><span class=o>,</span> <span class=n>1</span><span class=o>,</span><span class=n>2</span><span class=o>,</span><span class=n>3</span><span class=o>,</span><span class=n>4</span><span class=o>,</span><span class=n>5</span><span class=o>);</span>

      <span class=c1>//lambda表达式 方法引用
</span><span class=c1></span>      <span class=n>list</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>);</span>

      <span class=n>list</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>element</span> <span class=o>-&gt;</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>element</span> <span class=o>%</span> <span class=n>2</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
          <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>element</span><span class=o>);</span>
        <span class=o>}</span>
      <span class=o>});</span>
</code></pre></div><ul>
<li><strong>删除集合中的某个元素</strong></li>
</ul>
<p>我们通过<code>public boolean removeIf(Predicate&lt;? super E> filter)</code>方法来删除集合中的某个元素，Predicate 也是 jdk 为我们提供的一个函数式接口，可以简化程序的编写。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java>      <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>&gt;</span> <span class=n>items</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
      <span class=n>items</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>11</span><span class=o>,</span> <span class=s>&#34;小牙刷&#34;</span><span class=o>,</span> <span class=n>12</span><span class=o>.</span><span class=na>05</span> <span class=o>));</span>
      <span class=n>items</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>5</span><span class=o>,</span> <span class=s>&#34;日本马桶盖&#34;</span><span class=o>,</span> <span class=n>999</span><span class=o>.</span><span class=na>05</span> <span class=o>));</span>
      <span class=n>items</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>7</span><span class=o>,</span> <span class=s>&#34;格力空调&#34;</span><span class=o>,</span> <span class=n>888</span><span class=o>.</span><span class=na>88</span> <span class=o>));</span>
      <span class=n>items</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>17</span><span class=o>,</span> <span class=s>&#34;肥皂&#34;</span><span class=o>,</span> <span class=n>2</span><span class=o>.</span><span class=na>00</span> <span class=o>));</span>
      <span class=n>items</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>9</span><span class=o>,</span> <span class=s>&#34;冰箱&#34;</span><span class=o>,</span> <span class=n>4200</span><span class=o>.</span><span class=na>00</span> <span class=o>));</span>

      <span class=n>items</span><span class=o>.</span><span class=na>removeIf</span><span class=o>(</span><span class=n>ele</span> <span class=o>-&gt;</span> <span class=n>ele</span><span class=o>.</span><span class=na>getId</span><span class=o>()</span> <span class=o>==</span> <span class=n>7</span><span class=o>);</span>

      <span class=c1>//通过 foreach 遍历，查看是否已经删除
</span><span class=c1></span>      <span class=n>items</span><span class=o>.</span><span class=na>forEach</span><span class=o>(</span><span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>::</span><span class=n>println</span><span class=o>);</span>
</code></pre></div><ul>
<li><strong>集合内元素的排序</strong></li>
</ul>
<p>在以前我们若要为集合内的元素排序，就必须调用 sort 方法，传入比较器匿名内部类重写 compare 方法，我们现在可以使用 lambda 表达式来简化代码。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java>        <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>13</span><span class=o>,</span> <span class=s>&#34;背心&#34;</span><span class=o>,</span> <span class=n>7</span><span class=o>.</span><span class=na>80</span><span class=o>));</span>
        <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>11</span><span class=o>,</span> <span class=s>&#34;半袖&#34;</span><span class=o>,</span> <span class=n>37</span><span class=o>.</span><span class=na>80</span><span class=o>));</span>
        <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>14</span><span class=o>,</span> <span class=s>&#34;风衣&#34;</span><span class=o>,</span> <span class=n>139</span><span class=o>.</span><span class=na>80</span><span class=o>));</span>
        <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Item</span><span class=o>(</span><span class=n>12</span><span class=o>,</span> <span class=s>&#34;秋裤&#34;</span><span class=o>,</span> <span class=n>55</span><span class=o>.</span><span class=na>33</span><span class=o>));</span>

        <span class=cm>/*
</span><span class=cm>        list.sort(new Comparator&lt;Item&gt;() {
</span><span class=cm>            @Override
</span><span class=cm>            public int compare(Item o1, Item o2) {
</span><span class=cm>                return o1.getId()  - o2.getId();
</span><span class=cm>            }
</span><span class=cm>        });
</span><span class=cm>        */</span>

        <span class=n>list</span><span class=o>.</span><span class=na>sort</span><span class=o>((</span><span class=n>o1</span><span class=o>,</span> <span class=n>o2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>o1</span><span class=o>.</span><span class=na>getId</span><span class=o>()</span> <span class=o>-</span> <span class=n>o2</span><span class=o>.</span><span class=na>getId</span><span class=o>());</span>

        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>list</span><span class=o>);</span>
</code></pre></div><h3 id=lambda-表达式中的闭包问题>Lambda 表达式中的闭包问题<a hidden class=anchor aria-hidden=true href=#lambda-表达式中的闭包问题>#</a></h3>
<p>这个问题我们在匿名内部类中也会存在，如果我们把注释放开会报错，告诉我 num 值是 final 不能被改变。这里我们虽然没有标识 num 类型为 final，但是在编译期间虚拟机会帮我们加上 final 修饰关键字。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kn>import</span> <span class=nn>java.util.function.Consumer</span><span class=o>;</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Main</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>

        <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=n>10</span><span class=o>;</span>

        <span class=n>Consumer</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>consumer</span> <span class=o>=</span> <span class=n>ele</span> <span class=o>-&gt;</span> <span class=o>{</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>num</span><span class=o>);</span>
        <span class=o>};</span>

        <span class=c1>//num = num + 2;
</span><span class=c1></span>        <span class=n>consumer</span><span class=o>.</span><span class=na>accept</span><span class=o>(</span><span class=s>&#34;hello&#34;</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3>
<p>学会理解和写 Lambda 表达式的三步:</p>
<p><strong>1. 确认 Lambda 表达式的类型</strong>:</p>
<ul>
<li>能用 Lambda 表达式来表示的类型，必须是一个<strong>函数式接口</strong>，而函数式接口，就是只有一个抽象方法的接口。</li>
</ul>
<p><strong>2. 找到要实现的方法</strong>:</p>
<ul>
<li>Lambda 表达式就是实现一个方法，什么方法呢？就是刚刚那些函数式接口中的<strong>抽象方法</strong></li>
</ul>
<p><strong>3. 实现这个方法</strong>:</p>
<ul>
<li>Lambda 表达式就是要实现这个抽象方法，如果不用 Lambda 表达式，你一定知道用<strong>匿名类</strong>如何去实现</li>
</ul>
<p>Lambda 表达式的类型就是<strong>函数式接口</strong>，要实现的方法就是函数式接口里那个唯一的<strong>抽象方法</strong>，实现这个方法的方式就是<strong>参数块 + 小箭头 + 方法体</strong>，其中参数块和方法体都可以一定程度上简化它的写法。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://blog.addxe.com/tags/java/>Java</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://blog.addxe.com/posts/e32c011c/>
<span class=title>« Prev Page</span>
<br>
<span>Docker笔记</span>
</a>
<a class=next href=https://blog.addxe.com/posts/99c03bb5/>
<span class=title>Next Page »</span>
<br>
<span>Hackintosh安装</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://blog.addxe.com/>Earlのblog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script src=https://static.addxe.com/static/js/l2dwidget.min.js></script>
<script>var hijiki='/hijiki/assets/hijiki.model.json',config;function show(a){config.model.jsonPath=a,L2Dwidget.init(config)}config={model:{jsonPath:''},display:{superSample:1,width:180,height:290,position:'lift',hOffset:0,vOffset:0},mobile:{show:!0,scale:.75,motion:!0},react:{opacityDefault:1,opacityOnHover:1}},window.onload=function(){show(hijiki)}</script>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>