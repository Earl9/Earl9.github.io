<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>HashMap源码分析 | Earlのblog</title>
<meta name=keywords content="Java">
<meta name=description content="HashMap源码学习">
<meta name=author content>
<link rel=canonical href=https://www.wilds.top/posts/52ce4309/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.a1a1073ca47c48aad5c688a1c98be56e6c93d809db1f643397d7fbc03356fe0f.css integrity="sha256-oaEHPKR8SKrVxoihyYvlbmyT2AnbH2Qzl9f7wDNW/g8=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.wilds.top/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://www.wilds.top/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://www.wilds.top/favicon-32x32.png>
<link rel=apple-touch-icon href=https://www.wilds.top/apple-touch-icon.png>
<link rel=mask-icon href=https://www.wilds.top/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.91.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><style type=text/css>@font-face{font-family:myFont;src:url(https://git.wxfljc.cn/Earl/static/raw/branch/master/font/yuan.woff)}</style>
<link rel=stylesheet href=https://git.wxfljc.cn/Earl/static/raw/branch/master/js/highlight.min.js>
<script src=https://git.wxfljc.cn/Earl/static/raw/branch/master/css/androidstudio.min.css></script>
<script>hljs.highlightAll()</script>
<style>body{font-family:myFont,DFPHannotateW5-GB,SimHei,-apple-system,BlinkMacSystemFont,YouYuan,NSimSun,Yuanti SC,KaiTi,open sans,PingFang SC,sans-serif;font-size:19px}code{font-family:myFont,DFPHannotateW5-GB,SimHei,DFPHannotateW5-GB,-apple-system,BlinkMacSystemFont,YouYuan,NSimSun,KaiTi,Yuanti SC,Yuanti SC,open sans,sans-serif}</style>
<link rel=stylesheet href=https://git.wxfljc.cn/Earl/static/raw/branch/master/css/font-awesome.min.css>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K1T3V5VR8S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-K1T3V5VR8S',{anonymize_ip:!1})}</script>
<meta property="og:title" content="HashMap源码分析">
<meta property="og:description" content="HashMap源码学习">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.wilds.top/posts/52ce4309/"><meta property="og:image" content="https://www.wilds.top/papermod-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-05T22:47:12+08:00">
<meta property="article:modified_time" content="2021-12-05T22:47:12+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://www.wilds.top/papermod-cover.png">
<meta name=twitter:title content="HashMap源码分析">
<meta name=twitter:description content="HashMap源码学习">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.wilds.top/posts/"},{"@type":"ListItem","position":2,"name":"HashMap源码分析","item":"https://www.wilds.top/posts/52ce4309/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"HashMap源码分析","name":"HashMap源码分析","description":"HashMap源码学习","keywords":["Java"],"articleBody":"一、HashMap 集合简介   HashMap 基于 哈希表 (是根据关键码值(Key value)而直接进行访问的数据结构) 的 Map 接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null，此外，HashMap 中的映射不是有序的。\n  jdk1.8 之前 HashMap 由 数组 + 链表 组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突（两个对象调用的 hashCode 方法计算的哈希值一致导致计算的教组索引值相同）而存在的（“拉链法”解决冲突）。jdk1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。\n  补充：将链表转换成红黑树前会判断，即便阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树，而是选择逬行数组扩容。\n这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层阈值大于8并且数组长度大于64时，链表才转换为红黑树，具体可以参考 treeifyBin() 方法。\n当然,虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。\n  小结：\nHashMap 特点：\n 存储无序的。 键和值位置都可以是 null，但是键位置只能存在一个 null。 键位置是唯一的，是底层的数据结构控制的。 jdk1.8 前数据结构是链表+数组，jdk1.8 之后是链表+数组+红黑树。 阈值（边界值） 8 并且数组长度大于 64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。    二、HashMap 集合底层的数据结构 2.1数据结构概念 数据结构是[计算机]存储、组织[数据]的方式。数据结构是指相互之间存在一种或多种特定关系的[数据元素]的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储[效率]。数据结构往往同高效的检索[算法]和[索引]技术有关。\n数据结构:就是存储数据的一种方式;\n2.2 存储数据的过程 示例代码：\nHashMapString, Integer map = new HashMap(); map.put(\"柳岩\", 18); map.put(\"杨幂\", 28); map.put(\"刘德华\", 40); map.put(\"柳岩\", 20); 输出结果：\n{杨幂=28, 柳岩=20, 刘德华=40} 分析：\n  当创建 HashMap 集合对象的时候，在 jdk1.8 之前，构造方法中创建一个长度是16的 Entry[] table 用来存储键值对数据的。在 jdk1.8 以后不是在 HashMap 的构造方法底层创建数组了，是在第一次调用 put 方法时创建的数组 Node[] table 用来存储键值对数据。\n  假设向哈希表中存储  数据，根据柳岩调用 String 类中重写之后的 hashCode() 方法计算出值，然后结合数组长度采用某种算法计算出向 Node 数组中存储数据的空间的索引值。如果计算出的索引空间没有数据，则直接将存储到数组中。（举例：计算出的索引是 3 ）\n  向哈希表中存储数据 ，假设算出的 hashCode() 方法结合数组长度计算出的索引值也是3，那么此时数组空间不是 null，此时底层会比较柳岩和刘德华的 hash 值是否一致，如果不一致，则在空间上划出一个结点来存储键值对数据对 ，这种方式称为拉链法。\n  假设向哈希表中存储数据 ，那么首先根据柳岩调用 hashCode() 方法结合数组长度计算出索引是 3，此时比较后存储的数据柳岩和已经存在的数据的 hash 值是否相等，如果 hash 值相等，此时发生哈希碰撞。那么底层会调用柳岩所属类 String 中的 equals() 方法比较两个key的内容是否相等：\n相等：将后添加的数据的 value 覆盖之前的 value。\n不相等：继续向下和其他的数据的 key 进行比较，如果都不相等，则划出一个结点存储数据，如果结点长度即链表长度大于阈值 8 并且数组长度大于 64 则将链表变为红黑树。   在不断的添加数据的过程中，会涉及到扩容问题，当超出阈值（且要存放的位置非空）时，扩容。默认的扩容方式：扩容为原来容量的 2 倍，并将原有的数据复制过来。\n  综上描述，当位于一个表中的元素较多，即 hash 值相等但是内容不相等的元素较多时，通过 key 值依次查找的效率较低。而 jdk1.8 中，哈希表存储采用数组+链表+红黑树实现，当链表长度（阈值）超过8且当前数组的长度大于64时，将链表转换为红黑树，这样大大减少了查找时间。\n简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示：   jdk1.8 中引入红黑树的进一步原因：\njdk1.8以前 HashMap 的实现是数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当HashMap中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有n个元素，遍历的时间复杂度就是O(n)，完全失去了它的优势。\n针对这种情况，jdk1.8中引入了红黑树（查找时间复杂度为O(logn)）来优化这个问题。当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。\n关于时间复杂度O(n),O(logn)简介,参考:https://www.jianshu.com/p/f31744e423eb\n  总结：\n  说明：\n size 表示 HashMap 中键值对的实时数量，注意这个不等于数组的长度。 threshold（临界值）= capacity（容量）* loadFactor（负载因子）。这个值是当前已占用数组长度的最大值。size超过这个值就重新 resize（扩容），扩容后的 HashMap 容量是之前容量的两倍。  2.3 面试题  HashMap 中 hash 函数是怎么实现的？还有哪些hash函数的实现方式？ 答：对于 key 的 hashCode 做 hash 操作，无符号右移 16 位然后做异或运算。还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移 16 位异或运算效率是最高的。 什么是哈希碰撞，如何解决哈希碰撞？ 答：只要两个元素的 key 计算的哈希码值相同就会发生哈希碰撞。jdk8 之前使用链表解决哈希碰撞。jdk8之后使用链表 + 红黑树解决哈希碰撞。 如果两个键的 hashCode 相同，如何存储键值对？ 答：通过 equals 比较内容是否相同。相同：则新的 value 覆盖之前的 value。不相同：则将新的键值对添加到到链表后面，链表长度超过阈值 8 且数组长度超过64就转换为红黑树存储。  三、HashMap继承关系 HashMap继承关系如下图所示：\n说明：\n Cloneable 空接口，表示可以克隆。创建并返回 HashMap 对象的一个副本。 Serializable 序列化接口。属于标记性接口。HashMap 对象可以被序列化和反序列化。 AbstractMap 父类提供了 Map 实现接口。以最大限度地减少实现此接口所需的工作。  补充：\n通过上述继承关系我们发现一个很奇怪的现象，就是 HashMap 已经继承了AbstractMap 而 AbstractMap 类实现了Map 接口，那为什么 HashMap 还要在实现 Map 接口呢？同样在 ArrayList 中 LinkedLis 中都是这种结构。\n据 Java 集合框架的创始人 Josh Bloch 描述，这样的写法是一个失误。在 Java 集合框架中，类似这样的写法很多，最幵始写 Java 集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，jdk 的维护者，后来不认为这个小小的失误值得去修改，所以就这样保留下来了。\n四、HashMap 集合类的成员 4.1 成员变量 4.1.1 serialVersionUID 序列化版本号\nprivate static final long serialVersionUID = 362498820763181265L; 4.1.2 DEFAULT_LOAD_FACTOR 默认的负载因子\n（默认值 0.75）\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; 4.1.3 MAXIMUM_CAPACITY 集合最大容量\nstatic final int MAXIMUM_CAPACITY = 1  30; // 2的30次幂  4.1.4 UNTREEIFY_THRESHOLD 当链表的值小于 6 则会从红黑树转回链表\n// 当桶（bucket）上的结点数小于这个值，树转为链表 static final int UNTREEIFY_THRESHOLD = 6; 4.1.5 MIN_TREEIFY_CAPACITY 当 Map 里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于4*TREEIFY_THRESHOLD(8)\n// 桶中结构转化为红黑树对应的数组长度最小的值 static final int MIN_TREEIFY_CAPACITY = 64; 4.1.6 entrySet 用来存放缓存\n// 存放具体元素的集合 transient SetMap.EntryK,V entrySet; 4.1.7 size HashMap 中存放元素的个数(重点)\n// 存放元素的个数，注意这个不等于数组的长度  transient int size; size 为 HashMap 中 K-V 的实时数量，不是数组 table 的长度。\n4.1.8 modCount 用来记录 HashMap 的修改次数\n// 每次扩容和更改 map 结构的计数器  transient int modCount; 4.1.9 threshold 临界值\n用来调整大小下一个容量的值计算方式为（容量*负载因子）\n// 临界值 当实际大小（容量*负载因子）超过临界值时，会进行扩容 int threshold; 4.1.10 DEFAULT_INITIAL_CAPACITY 集合的初始化容量（必须是 2 的 n 次幂）\n// 默认的初始容量是16\t1 static final int DEFAULT_INITIAL_CAPACITY = 1  4; 问题：初始化容量为什么必须是 2 的 n 次幂？\nHashMap 构造方法还可以指定集合的初始化容量大小：\n// 构造一个带指定初始容量和默认负载因子（0.75)的空 HashMap。 HashMap(int initialCapacity) 因为当向 HashMap 中添加一个元素的时候，需要根据 key 的 hash 值，去确定其在数组中的具体位置。HashMap 为了存取高效，减少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现的关键就在于把数据存到哪个链表中的算法。\n这个算法实际就是取模，hash % length，计算机中直接求余效率不如位移运算。所以源码中做了优化，使用 hash \u0026 (length - 1)，而实际上 hash % length 等于 hash \u0026 ( length - 1) ,所以前提必须是 length 是 2 的 n 次幂。\n问题又来了：为什么这样就能均匀分布减少碰撞呢?\n举例:\n说明:按位与运算规则:相同的二进制数位上,都是1的时候,结果为1.否则为0;\n例如: 如果数组长度是2的次幂 hash : 3 length数组长度 : 8(是) 3 \u0026 (8-1) 00000011 3 00000111 7 ------------ 00000011 3 索引 hash : 2 length数组长度 : 8(是) 2 \u0026 (8-1) 00000010 2 00000111 7 ------------ 00000010 2 索引 =============================================================== 例如: 如果数组长度不是2的次幂 hash : 3 length数组长度 : 9(不是) 3 \u0026 (9-1) 00000011 3 00001000 8 ------------ 00000000 0 索引 hash : 2 length数组长度 : 9(不是) 2 \u0026 (9-1) 00000010 2 00001000 8 ------------ 00000000 0 索引 总结:如果数组长度不是2的次幂,计算出的索引特别容易相同,及其容易发生hash碰撞,导致其余数组空间很大程度上并没有存储数据,链表或者红黑树过长,效率降低.\n问题：如果初始容量不设置2的次幂,比如10呢?\n/** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) {//10  int n = cap - 1; n |= n  1; n |= n  2; n |= n  4; n |= n  8; n |= n  16; return (n  0) ? 1 : (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } | 按位或运算规则: 相同的二进制数位上,都是0的时候,结果为0.否则为1  无符号右移 说明：\n当在实例化 HashMap 实例时，如果给定了 initialCapacity，由于 HashMap 的 capacity 必须都是 2 的次幂，因此这个方法用于找到大于等于 initialCapacity 的最小的 2 的幂。\n分析：\nint n = cap - 1; 防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂，又没有这个减 1 操作，则执行完后面的几条无符号操作之后，返回的 capacity 将是这个 cap 的 2 倍。\n完整例子：\n注意：得到的这个 capacity(容量) 却被赋值给了 threshold(临界值(容量*负载因子))。\n思考一下: capacity 被赋值给了 threshold这样有没有问题?后面讲解\nthis.threshold = tableSizeFor(initialCapacity); 4.1.11 TREEIFY_THRESHOLD 当链表的值超过8则会转为红黑树（jdk1.8新增）\n// 当桶（bucket）上的结点数大于这个值时会转为红黑树 static final int TREEIFY_THRESHOLD = 8; 问题：为什么 Map 桶中结点个数超过 8 才转为红黑树？\n我们都知道，链表的时间复杂度是O(n)，红黑树的时间复杂度O(logn)，很显然，红黑树的复杂度是优于链表的，既然这么棒，那为什么hashmap为什么不直接就用红黑树呢?请看下图\n在 HashMap 中有一段注释说明：\nBecause TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http://en.wikipedia.org/wiki/Poisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The first values are: 翻译：因为树结点的大小大约是普通结点的两倍，所以我们只在箱子包含足够的结点时才使用树结点(参见TREEIFY_THRESHOLD)。 当它们变得太小（由于删除或调整大小）时，就会被转换回普通的桶。在使用分布良好的用户 hashCode 时，很少使用树箱。 理想情况下，在随机哈希码下，箱子中结点的频率服从泊松分布 (http://en.wikipedia.org/wiki/Poisson_distribution) ，默认调整阈值为0.75，平均参数约为0.5，尽管由 于调整粒度的差异很大。忽略方差，列表大小k的预朗出现次数是(exp(-0.5) * pow(0.5, k) / factorial(k))。 第一个值是： 0: 0.60653066 1: 0.30326533 2: 0.07581633 3: 0.01263606 4: 0.00157952 5: 0.00015795 6: 0.00001316 7: 0.00000094 8: 0.00000006 more: less than 1 in ten million 源码中的注释写的很清楚，因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。\n为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点遵循泊松分布，而且根据统计，链表中节点数是8的概率已经接近千万分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。\n综上所述,我们可以看到，一个 桶 中链表长度达到 8 个元素的槪率为 0.00000006，几乎是不可能事件。所以，之所以选择 8，不是随便決定的，而是裉据概率统计决定的。甶此可见，发展将近30年的 Java 每一项改动和优化都是非常严谨和科学的。\n也就是说：选择 8 因为符合泊松分布，超过 8 的时候，概率已经非常小了，所以我们选择 8 这个数宇。\n  以下是在一些资料上面翻看的解释，供大家参考：\n红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8) = 3，链表的平均查找长度为 n/2，当长度为 8 时，平均查找长虔为 8/2 = 4，这才有转换成树的必要；链表长度如果是小于等于 6， 6/2 = 3，而 log(6) = 2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。\n  4.1.12 table table 用来初始化（必须是2的n次幂）(重点)\n// 存储元素的数组 transient NodeK,V[] table; 在 jdk1.8 中我们了解到 HashMap 是由数组加链表加红黑树来组成的结构，其中 table 就是 HashMap 中的数组，jdk8 之前数组类型是 Entry 类型。从 jdk1.8 之后是 Node 类型。只是换了个名字，都实现了一样的接口：Map.Entry。负责存储键值对数据的。\n4.1.13 loadFactor 负载因子,哈希表的负载因子(重点)\n// 负载因子 final float loadFactor; 说明：\n loadFactor 是用来衡量 HashMap 满的程度，表示HashMap的疏密程度，影响 hash 操作到同一个数组位置的概率 loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 当 HashMap 里面容纳的元素已经达到 HashMap 数组长度的 75% 时，表示 HashMap 太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。所以开发中尽量减少扩容的次数，可以通过创建 HashMap 集合对象时指定初始容量来尽量避免。 在 HashMap 的构造器中可以定制 loadFactor。  // 构造方法，构造一个带指定初始容量和负载因子的空HashMap HashMap(int initialCapacity, float loadFactor);   为什么负载因子设置为0.75，初始化临界值是12？\nloadFactor 越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，\nloadFactor 越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。\n如果希望链表尽可能少些，要提前扩容。有的数组空间有可能一直没有存储数据，负载因子尽可能小一些。\n  举例：\n例如：负载因子是0.4。 那么16*0.4---6 如果数组中满6个空间就扩容会造成数组利用率太低了。 负载因子是0.9。 那么16*0.9---14 那么这样就会导致链表有点多了，导致查找元素效率低。 所以既兼顾数组利用率又考虑链表不要太多，经过大量测试 0.75 是最佳方案。\n  threshold 计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。\n这个值是当前已占用数组长度的最大值。当 Size = threshold 的时候，那么就要考虑对数组的 resize(扩容)，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。 扩容后的 HashMap 容量是之前容量的两倍。\n  4.2 构造方法 HashMap 中重要的构造方法，它们分别如下：\n4.2.1 HashMap() 构造一个空的HashMap，默认初始容量（16）和默认负载因子（0.75）。\npublic HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // 将默认的负载因子0.75赋值给loadFactor，并没有创建数组 } 4.2.2 HashMap(int initialCapacity) 构造一个具有指定的初始容量和默认负载因子（0.75）HashMap 。\n// 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } 4.2.3 HashMap(int initialCapacity, float loadFactor) 构造一个具有指定的初始容量和负载因子的 HashMap。\n/* 指定“容量大小”和“负载因子”的构造函数 initialCapacity：指定的容量 loadFactor:指定的负载因子 */ public HashMap(int initialCapacity, float loadFactor) { // 判断初始化容量initialCapacity是否小于0  if (initialCapacity  0) // 如果小于0，则抛出非法的参数异常IllegalArgumentException  throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // 判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY  if (initialCapacity  MAXIMUM_CAPACITY) // 如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity  initialCapacity = MAXIMUM_CAPACITY; // 判断负载因子loadFactor是否小于等于0或者是否是一个非数值  if (loadFactor  0 || Float.isNaN(loadFactor)) // 如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException  throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); // 将指定的负载因子赋值给HashMap成员变量的负载因子loadFactor  this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } // 最后调用了tableSizeFor，来看一下方法实现：  /* 返回比指定初始化容量大的最小的2的n次幂 */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n  1; n |= n  2; n |= n  4; n |= n  8; n |= n  16; return (n  0) ? 1 : (n = MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 说明：\n对于 javathis.threshold = tableSizeFor(initialCapacity); 疑问解答：\ntableSizeFor(initialCapacity)判断指定的初始化容量是否是2的n次幂，如果不是那么会变为大于等于 initialCapacity 的最小的 2 的幂。 但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边界值了。有些人会觉得这里是一个bug，应该这样书写： this.threshold = tableSizeFor(initialCapacity) * this.loadFactor; 这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。 但是请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算。 4.2.4 HashMap(Mapm) 了解 包含另一个 “Map” 的构造函数\n// 构造一个映射关系与指定 Map 相同的新 HashMap。 public HashMap(Map extends K, ? extends V m) { // 负载因子loadFactor变为默认的负载因子0.75  this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); } 最后调用了 putMapEntries()，来看一下方法实现：\nfinal void putMapEntries(Map extends K, ? extends V m, boolean evict) { //获取参数集合的长度  int s = m.size(); if (s  0) { //判断参数集合的长度是否大于0，说明大于0  if (table == null) { // 判断table是否已经初始化  // 未初始化，s为m的实际元素个数  float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft  (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值  if (t  threshold) threshold = tableSizeFor(t); } // 已初始化，并且m元素个数大于阈值，进行扩容处理  else if (s  threshold) resize(); // 将m中的所有元素添加至HashMap中  for (Map.Entry extends K, ? extends V e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } 注意：(了解)\nfloat ft = ((float)s / loadFactor) + 1.0F; 这一行代码中为什么要加 1.0F ？\ns/loadFactor 的结果是小数，加 1.0F 与 (int)ft 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数。所以 + 1.0F 是为了获取更大的容量。\n例如：原来集合的元素个数是 6 个，那么 6/0.75 是8，是 2 的n次幂，那么新的数组大小就是 8 了。然后原来数组的数据就会存储到长度是 8 的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果 +1 呢，数组长度直接变为16了，这样可以减少数组的扩容。\n4.3 成员方法 4.3.1 增加方法 put() (重点) put方法是比较复杂的，实现步骤大致如下：\n  先通过 hash 值计算出 key 映射到哪个桶；\n  如果桶上没有碰撞冲突，则直接插入；\n  如果出现碰撞冲突了，则需要处理冲突：\na 如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；\nb 否则采用传统的链式方法插入。如果链的长度达到阈值，则把链转变为红黑树；\n  如果桶中存在重复的键，则为该键替换新值 value；\n  如果 size 大于临界值 threshold，则进行扩容；\n  具体的方法如下：\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 说明：\n HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。 所以我们重点看 putVal 方法。 我们可以看到在 putVal 方法中 key 在这里执行了一下 hash 方法,来看一下 hash 方法是如何实现的。  static final int hash(Object key) { int h; /* 1）如果key等于null：返回的是0. 2）如果key不等于null：首先计算出key的hashCode赋值给h，然后与h无符号右移16位后的 二进制进行按位异或得到最后的hash值 */ return (key == null) ? 0 : (h = key.hashCode()) ^ (h  16); } 从上面可以得知 HashMap 是支持 key 为空的，而 HashTable 是直接用 Key 来获取hashCode 所以 key 为空会抛异常。\n解读上述 hash 方法：\n我们先研究下 key 的哈希值是如何计算出来的。\n这个哈希方法首先计算出 key 的 hashCode 赋值给 h，然后与 h 无符号右移 16 位后的二进制进行按位异或得到最后的 hash 值。\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h  16); } 在 putVal 函数中使用到了上述 hash 函数计算的哈希值：\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { ... if ((p = tab[i = (n - 1) \u0026 hash]) == null) // 这里的n表示数组长度16 \t... } 计算过程如下所示：\n说明：\n key.hashCode()；返回散列值也就是 hashcode，假设随便生成的一个值。 n 表示数组初始化的长度是 16。 \u0026（按位与运算）：运算规则：相同的二进制数位上，都是 1 的时候，结果为 1，否则为0。 ^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为 0，不同为 1。  简单来说就是：\n高 16bit 不变，低 16bit 和高 16bit 做了一个异或（得到的 hashCode 转化为 32 位二进制，前 16 位和后 16 位,低 16bit 和高 16bit 做了一个异或）。\n问题：为什么要这样操作呢？\n如果当 n 即数组长度很小，假设是 16 的话，那么 n - 1 即为 1111(15的二进制表示) ，这样的值和 hashCode 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。\n假设hashCode值直接和数组长度(n-1)按位与运算 1111 1111 1111 1111 1111 0000 1110 1010 h=key.hashCode()，假设随便生成的一个值。 0000 0000 0000 0000 0000 0000 0000 1111 (16 - 1) --------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 1010 10索引 再存储一个key计算出hashCode值:加入高位变化很大,低位没有改变 1001 1001 1001 1111 1111 0000 1110 1010 0000 0000 0000 0000 0000 0000 0000 1111 (16 - 1) --------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 1010 10索引 现在看 putVal 方法，看看它到底做了什么。\n主要参数：\n hash：key 的 hash 值 key：原始 key value：要存放的值 onlyIfAbsent：如果 true 代表不更改现有的值 evict：如果为false表示 table 为创建状态  putVal 方法源代码如下所示：\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { NodeK,V[] tab; NodeK,V p; int n, i; /* 1）transient Node[] table; 表示存储Map集合中元素的数组。 2）(tab = table) == null 表示将空的table赋值给tab，然后判断tab是否等于null，第一次肯定是null。 3）(n = tab.length) == 0 表示将数组的长度0赋值给n，然后判断n是否等于0，n等于0，由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化，并将初始化好的数组长度赋值给n。 4）执行完n = (tab = resize()).length，数组tab每个空间都是null。 */ if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /* 1）i = (n - 1) \u0026 hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中。 2）p = tab[i = (n - 1) \u0026 hash]表示获取计算出的位置的数据赋值给结点p。 3) (p = tab[i = (n - 1) \u0026 hash]) == null 判断结点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的结点放入该位置的桶中。 小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置。 */ if ((p = tab[i = (n - 1) \u0026 hash]) == null) // 创建一个新的结点存入到桶中  tab[i] = newNode(hash, key, value, null); else { // 执行else说明tab[i]不等于null，表示这个位置已经有值了  NodeK,V e; K k; /* 比较桶中第一个元素(数组中的结点)的hash值和key是否相等 1）p.hash == hash ：p.hash表示原来存在数据的hash值 hash表示后添加数据的hash值 比较两个hash值是否相等。 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。 Node newNode(int hash, K key, V value, Node next) { return new Node(hash, key, value, next); } 而在Node类中具有成员变量hash用来记录着之前数据的hash值的。 2）(k = p.key) == key ：p.key获取原来数据的key赋值给k key 表示后添加数据的key比较两个key的地址值是否相等。 3）key != null \u0026\u0026 key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等。 */ if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) /* 说明：两个元素哈希值相等，并且key的值也相等，将旧的元素整体对象赋值给e，用e来记录 */ e = p; // hash值不相等或者key不相等；判断p是否为红黑树结点  else if (p instanceof TreeNode) // 放入树中  e = ((TreeNodeK,V)p).putTreeVal(this, tab, hash, key, value); // 说明是链表结点  else { /* 1)如果是链表的话需要遍历到最后结点然后插入 2)采用循环遍历的方式，判断链表中是否有重复的key */ for (int binCount = 0; ; ++binCount) { /* 1)e = p.next 获取p的下一个元素赋值给e。 2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键，将该键值对插入链表中。 */ if ((e = p.next) == null) { /* 1）创建一个新的结点插入到尾部 p.next = newNode(hash, key, value, null); Node newNode(int hash, K key, V value, Node next) { return new Node(hash, key, value, next); } 注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个结点肯定是null。 2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素。 */ p.next = newNode(hash, key, value, null); /* 1)结点添加完成之后判断此时结点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树。 2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历结点的个数。值是0表示第一个结点，1表示第二个结点。。。。7表示第八个结点，加上数组中的的一个元素，元素个数是9。 TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7 如果binCount的值是7(加上数组中的的一个元素，元素个数是9) TREEIFY_THRESHOLD - 1也是7，此时转换红黑树。 */ if (binCount = TREEIFY_THRESHOLD - 1) // -1 for 1st  // 转换为红黑树  treeifyBin(tab, hash); // 跳出循环  break; } /* 执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插入的元素的key值是否相等。 */ if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) // 相等，跳出循环  /* 要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了 直接执行下面的if语句去替换去 if (e != null) */ break; /* 说明新添加的元素和当前结点不相等，继续查找下一个结点。 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 */ p = e; } } /* 表示在桶中找到key值、hash值与插入元素相等的结点 也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值 这里完成了put方法的修改功能 */ if (e != null) { // 记录e的value  V oldValue = e.value; // onlyIfAbsent为false或者旧值为null  if (!onlyIfAbsent || oldValue == null) // 用新值替换旧值  // e.value 表示旧值 value表示新值  e.value = value; // 访问后回调  afterNodeAccess(e); // 返回旧值  return oldValue; } } // 修改记录次数  ++modCount; // 判断实际大小是否大于threshold阈值，如果超过则扩容  if (++size  threshold) resize(); // 插入后回调  afterNodeInsertion(evict); return null; } 4.3.2 将链表转换为红黑树 treeifyBin() (了解) 结点添加完成之后判断此时结点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：\nif (binCount = TREEIFY_THRESHOLD - 1) // -1 for 1st  //转换为红黑树 tab表示数组名 hash表示哈希值  treeifyBin(tab, hash); treeifyBin 方法如下所示：\n/* 替换指定哈希表的索引处桶中的所有链接结点，除非表太小，否则将修改大小。 Node[] tab = tab 数组名 int hash = hash表示哈希值 */ final void treeifyBin(NodeK,V[] tab, int hash) { int n, index; NodeK,V e; /* 如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)，就去扩容。而不是将结点变为红黑树。 目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。 */ if (tab == null || (n = tab.length)  MIN_TREEIFY_CAPACITY) //扩容方法  resize(); else if ((e = tab[index = (n - 1) \u0026 hash]) != null) { /* 1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化 2）e = tab[index = (n - 1) \u0026 hash]表示将数组中的元素取出赋值给e，e是哈希表中指定位置桶里的链表结点，从第一个开始 */ // hd：红黑树的头结点 tl：红黑树的尾结点  TreeNodeK,V hd = null, tl = null; do { // 新创建一个树的结点，内容和当前链表结点e一致  TreeNodeK,V p = replacementTreeNode(e, null); if (tl == null) hd = p; // 将新创键的p结点赋值给红黑树的头结点  else { p.prev = tl; // 将上一个结点p赋值给现在的p的前一个结点  tl.next = p; // 将现在结点p作为树的尾结点的下一个结点  } tl = p; /* e = e.next 将当前结点的下一个结点赋值给e，如果下一个结点不等于null 则回到上面继续取出链表中结点转换为红黑树 */ } while ((e = e.next) != null); /* 让桶中的第一个元素即数组中的元素指向新建的红黑树的结点，以后这个桶里的元素就是红黑树 而不是链表数据结构了 */ if ((tab[index] = hd) != null) hd.treeify(tab); } } 小结：上述操作一共做了如下几件事：\n 根据哈希表中元素个数确定是扩容还是树形化。 如果是树形化遍历桶中的元素，创建相同个数的树形结点，复制内容，建立起联系。 然后让桶中的第一个元素指向新创建的树根结点，替换桶的链表内容为树形化内容。  4.3.3 扩容方法 resize() (重点) 扩容机制：\n  什么时候才需要扩容\n当 HashMap 中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor 的默认值是 0.75。\n  HashMap 的扩容是什么\n进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。\n设计计算hash值时，要避免出现hash冲突。也就是说不能让它出现链表，更不应该出现红黑树，这样性能很差，如果出现了，证明hash算法，设计的太差。为了避免hash冲突，一，hash算法，二，加载因子。\nHashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n - 1) \u0026 hash 的结果相比，只是多了一个 bit 位，所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。\n例如我们从 16 扩展为 32 时，具体的变化如下所示：\n  源数组长度: 16 n = 16 n-1=15 (n-1) \u0026 hash 0000 0000 0000 0000 0000 0000 0001 0000 16 0000 0000 0000 0000 0000 0000 0000 1111 15 n-1 假设一个hash1(key1): 1111 1111 1111 1111 0000 1111 0000 0101 ----------------------------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0101 索引 5 0000 0000 0000 0000 0000 0000 0000 1111 15 n-1 假设一个hash2(key2): 1111 1111 1111 1111 0000 1111 0001 0101\t----------------------------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0101 索引 5 ======================================================================================= 此时数组扩容-- 16 * 2 = 32 n = 32 n-1=31 (n-1) \u0026 hash 0000 0000 0000 0000 0000 0000 0010 0000 32 0000 0000 0000 0000 0000 0000 0001 1111 31 n-1 假设一个hash1(key1): 1111 1111 1111 1111 0000 1111 0000 0101 ----------------------------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0101 索引 5 0000 0000 0000 0000 0000 0000 0001 1111 31 n-1 假设一个hash2(key2): 1111 1111 1111 1111 0000 1111 0001 0101\t----------------------------------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0001 0101 索引 5 + 16 扩容之后的索引位置要么是原来索引,要么是原来索引 + 旧数组容量 举例: 5 或者 5 + 16 因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n - 1 的标记范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化。\n说明：\n5 是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以结点要么就在原来的位置，要么就被分配到 “原位置 + 旧容量” 这个位置。\n因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了，是 0 的话索引没变，是 1 的话索引变成 “原位置 + 旧容量” 。可以看看下图为 16 扩充为 32 的 resize 示意图：\n正是因为这样巧妙的 rehash 方式，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，在 resize 的过程中保证了 rehash 之后每个桶上的结点数一定小于等于原来桶上的结点数，保证了 rehash 之后不会出现更严重的 hash 冲突，均匀的把之前的冲突的结点分散到新的桶中了。\n源码 resize 方法的解读\n下面是代码的具体实现：\nfinal NodeK,V[] resize() { // 得到当前数组  NodeK,V[] oldTab = table; // 如果当前数组等于null长度返回0，否则返回当前数组的长度  int oldCap = (oldTab == null) ? 0 : oldTab.length; //当前阀值点 默认是12(16*0.75)  int oldThr = threshold; int newCap, newThr = 0; // 如果老的数组长度大于0  // 开始计算扩容后的大小  if (oldCap  0) { // 超过最大值就不再扩充了，就只好随你碰撞去吧  if (oldCap = MAXIMUM_CAPACITY) { // 修改阈值为int的最大值  threshold = Integer.MAX_VALUE; return oldTab; } /* 没超过最大值，就扩充为原来的2倍 1) (newCap = oldCap 2）oldCap = DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16 */ else if ((newCap = oldCap  1)  MAXIMUM_CAPACITY \u0026\u0026 oldCap = DEFAULT_INITIAL_CAPACITY) // 阈值扩大一倍  newThr = oldThr  1; // double threshold  } // 老阈值点大于0 直接赋值  else if (oldThr  0) // 老阈值赋值给新的数组长度  newCap = oldThr; else { // 直接使用默认值  newCap = DEFAULT_INITIAL_CAPACITY;//16  newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的resize最大上限  if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap  MAXIMUM_CAPACITY \u0026\u0026 ft  (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } // 新的阀值 默认原来是12 乘以2之后变为24  threshold = newThr; // 创建新的哈希表  @SuppressWarnings({\"rawtypes\",\"unchecked\"}) //newCap是新的数组长度--》32  NodeK,V[] newTab = (NodeK,V[])new Node[newCap]; table = newTab; // 判断旧数组是否等于空  if (oldTab != null) { // 把每个bucket都移动到新的buckets中  // 遍历旧的哈希表的每个桶，重新计算桶里元素的新位置  for (int j = 0; j  oldCap; ++j) { NodeK,V e; if ((e = oldTab[j]) != null) { // 原来的数据赋值为null 便于GC回收  oldTab[j] = null; // 判断数组是否有下一个引用  if (e.next == null) // 没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入  newTab[e.hash \u0026 (newCap - 1)] = e; //判断是否是红黑树  else if (e instanceof TreeNode) // 说明是红黑树来处理冲突的，则调用相关方法把树分开  ((TreeNodeK,V)e).split(this, newTab, j, oldCap); else { // 采用链表处理冲突  NodeK,V loHead = null, loTail = null; NodeK,V hiHead = null, hiTail = null; NodeK,V next; // 通过上述讲解的原理来计算结点的新位置  do { // 原索引  next = e.next; // 这里来判断如果等于true e这个结点在resize之后不需要移动位置  if ((e.hash \u0026 oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引+oldCap  else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里  if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket里  if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 4.3.5 查找元素方法 get() (重点) 查找方法，通过元素的 key 找到 value。\n代码如下：\npublic V get(Object key) { NodeK,V e; return (e = getNode(hash(key), key)) == null ? null : e.value; } get 方法主要调用的是 getNode 方法，代码如下：\nfinal NodeK,V getNode(int hash, Object key) { NodeK,V[] tab; NodeK,V first, e; int n; K k; // 如果哈希表不为空并且key对应的桶上不为空  if ((tab = table) != null \u0026\u0026 (n = tab.length)  0 \u0026\u0026 (first = tab[(n - 1) \u0026 hash]) != null) { /* 判断数组元素是否相等 根据索引的位置检查第一个元素 注意：总是检查第一个元素 */ if (first.hash == hash \u0026\u0026 // always check first node  ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k)))) return first; // 如果不是第一个元素，判断是否有后续结点  if ((e = first.next) != null) { // 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取结点  if (first instanceof TreeNode) return ((TreeNodeK,V)first).getTreeNode(hash, key); do { // 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key  if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 小结：\n  get 方法实现的步骤：\na. 通过 hash 值获取该 key 映射到的桶 b. 桶上的 key 就是要查找的 key，则直接找到并返回 c. 桶上的 key 不是要找的 key，则查看后续的结点：\n\t如果后续结点是红黑树结点，通过调用红黑树的方法根据 key 获取 value 如果后续结点是链表结点，则通过循环遍历链表根据 key 获取 value   上述红黑树结点调用的是 getTreeNode 方法通过树形结点的 find 方法进行查找：\n  final TreeNodeK,V getTreeNode(int h, Object k) { return ((parent != null) ? root() : this).find(h, k, null); } final TreeNodeK,V find(int h, Object k, Class kc) { TreeNodeK,V p = this; do { int ph, dir; K pk; TreeNodeK,V pl = p.left, pr = p.right, q; if ((ph = p.hash)  h) p = pl; else if (ph  h) p = pr; else if ((pk = p.key) == k || (k != null \u0026\u0026 k.equals(pk))) return p; // 找到之后直接返回  else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) \u0026\u0026 (dir = compareComparables(kc, k, pk)) != 0) p = (dir  0) ? pl : pr; // 递归查找  else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; } while (p != null); return null; }  查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。 这里和插入时一样，如果对比结点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。 若为树，则在树中通过key.equals(k)查找，O(logn)。若为链表，则在链表中通过key.equals(k)查找，O(n)。  4.3.6 遍历 HashMap 集合几种方式 1.分别遍历 Key 和 Values\nfor (String key : map.keySet()) { System.out.println(key); } for (Object vlaue : map.values() { System.out.println(value); } 2.使用 Iterator 迭代器迭代\nIteratorMap.EntryString, Object iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.EntryString, Object mapEntry = iterator.next(); System.out.println(mapEntry.getKey() + \"---\" + mapEntry.getValue()); } 3.通过 get 方式（不建议使用）\nSetString keySet = map.keySet(); for (String str : keySet) { System.out.println(str + \"---\" + map.get(str)); } 说明：\n根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet 获取 Iterator一次，还有通过 get 又迭代一次，降低性能。\n jdk8 以后使用 Map 接口中的默认方法：  default void forEach(BiConsumer super K,? super V action) // BiConsumer接口中的方法： \tvoid accept(T t, U u) 对给定的参数执行此操作。 参数 t - 第一个输入参数 u - 第二个输入参数 遍历代码：\nHashMapString,String map = new HashMap(); map.put(\"001\", \"zhangsan\"); map.put(\"002\", \"lisi\"); map.forEach((key, value) - { System.out.println(key + \"---\" + value); }); 五、设计 HashMap 的初始化容量 5.1 问题描述 如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化 HashMap 的时候就应该指定它的容量，以防止 HashMap 自动扩容，影响使用效率。\n默认情况下 HashMap 的容量是 16，但是，如果用户通过构造函数指定了一个数字作为容量，那么 Hash 会选择大于该数字的第一个 2 的幂作为容量（3-4、7-8、9-16）。这点我们在上述已经进行过讲解。\n5.2 《阿里巴巴Java开发手册》的建议 《阿里巴巴Java开发手册》原文：\n关于设置 HashMap 的初始化容量：\n我们上面介绍过，HashMap 的扩容机制，就是当达到扩容条件时会进行扩容。HashMap 的扩容条件就是当 HashMap 中的元素个数（size）超过临界值（threshold）时就会自动扩容。所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap 会有可能发生多次扩容，而 HashMap 中的扩容机制决定了每次扩容都需要重建 hash 表，是非常影响性能的。\n但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知 HashMap 中即将存放的 KV 个数的时候，容量设置成多少为好呢？\n关于设置 HashMap 的初始化容量大小：\n可以认为，当我们明确知道 HashMap 中元素的个数的时候，把默认容量设置成 initialCapacity/ 0.75F + 1.0F 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。\n而 Jdk 并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个 2 的幂。\n","wordCount":"3335","inLanguage":"en","datePublished":"2021-12-05T22:47:12+08:00","dateModified":"2021-12-05T22:47:12+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.wilds.top/posts/52ce4309/"},"publisher":{"@type":"Organization","name":"Earlのblog","logo":{"@type":"ImageObject","url":"https://www.wilds.top/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.wilds.top/ accesskey=h title="Earlのblog (Alt + H)">Earlのblog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://www.wilds.top/search title>
<span><i class="fa fa-search"></i></span>
</a>
</li>
<li>
<a href=https://www.wilds.top/archives/ title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://www.wilds.top/categories title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://www.wilds.top/tags title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://www.wilds.top/friends/ title=Friends>
<span>Friends</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://www.wilds.top/>Home</a>&nbsp;»&nbsp;<a href=https://www.wilds.top/posts/>Posts</a></div>
<h1 class=post-title>
HashMap源码分析
</h1>
<div class=post-description>
HashMap源码学习
</div>
<div class=post-meta><span title="2021-12-05 22:47:12 +0800 CST">December 5, 2021</span>&nbsp;·&nbsp;16 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e4%b8%80hashmap-%e9%9b%86%e5%90%88%e7%ae%80%e4%bb%8b aria-label="一、HashMap 集合简介">一、HashMap 集合简介</a></li>
<li>
<a href=#%e4%ba%8chashmap-%e9%9b%86%e5%90%88%e5%ba%95%e5%b1%82%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="二、HashMap 集合底层的数据结构">二、HashMap 集合底层的数据结构</a><ul>
<li>
<a href=#21%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%a6%82%e5%bf%b5 aria-label=2.1数据结构概念>2.1数据结构概念</a></li>
<li>
<a href=#22-%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae%e7%9a%84%e8%bf%87%e7%a8%8b aria-label="2.2 存储数据的过程">2.2 存储数据的过程</a></li>
<li>
<a href=#23-%e9%9d%a2%e8%af%95%e9%a2%98 aria-label="2.3 面试题">2.3 面试题</a></li></ul>
</li>
<li>
<a href=#%e4%b8%89hashmap%e7%bb%a7%e6%89%bf%e5%85%b3%e7%b3%bb aria-label=三、HashMap继承关系>三、HashMap继承关系</a></li>
<li>
<a href=#%e5%9b%9bhashmap-%e9%9b%86%e5%90%88%e7%b1%bb%e7%9a%84%e6%88%90%e5%91%98 aria-label="四、HashMap 集合类的成员">四、HashMap 集合类的成员</a><ul>
<li>
<a href=#41-%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f aria-label="4.1 成员变量">4.1 成员变量</a><ul>
<ul>
<li>
<a href=#411--serialversionuid aria-label="4.1.1  serialVersionUID">4.1.1 serialVersionUID</a></li>
<li>
<a href=#412--default_load_factor aria-label="4.1.2  DEFAULT_LOAD_FACTOR">4.1.2 DEFAULT_LOAD_FACTOR</a></li>
<li>
<a href=#413-maximum_capacity aria-label="4.1.3 MAXIMUM_CAPACITY">4.1.3 MAXIMUM_CAPACITY</a></li>
<li>
<a href=#414-untreeify_threshold aria-label="4.1.4 UNTREEIFY_THRESHOLD">4.1.4 UNTREEIFY_THRESHOLD</a></li>
<li>
<a href=#415-min_treeify_capacity aria-label="4.1.5 MIN_TREEIFY_CAPACITY">4.1.5 MIN_TREEIFY_CAPACITY</a></li>
<li>
<a href=#416-entryset aria-label="4.1.6 entrySet">4.1.6 entrySet</a></li>
<li>
<a href=#417-size aria-label="4.1.7 size">4.1.7 size</a></li>
<li>
<a href=#418-modcount aria-label="4.1.8 modCount">4.1.8 modCount</a></li>
<li>
<a href=#419-threshold aria-label="4.1.9 threshold">4.1.9 threshold</a></li>
<li>
<a href=#4110-default_initial_capacity aria-label="4.1.10 DEFAULT_INITIAL_CAPACITY">4.1.10 DEFAULT_INITIAL_CAPACITY</a></li>
<li>
<a href=#4111-treeify_threshold aria-label="4.1.11 TREEIFY_THRESHOLD">4.1.11 TREEIFY_THRESHOLD</a></li>
<li>
<a href=#4112-table aria-label="4.1.12 table">4.1.12 table</a></li>
<li>
<a href=#4113-loadfactor aria-label="4.1.13 loadFactor">4.1.13 loadFactor</a></li></ul>
</ul>
</li>
<li>
<a href=#42-%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95 aria-label="4.2 构造方法">4.2 构造方法</a><ul>
<ul>
<li>
<a href=#421-hashmap aria-label="4.2.1 HashMap()">4.2.1 HashMap()</a></li>
<li>
<a href=#422-hashmapint-initialcapacity aria-label="4.2.2 HashMap(int initialCapacity)">4.2.2 HashMap(int initialCapacity)</a></li>
<li>
<a href=#423-hashmapint-initialcapacity-float-loadfactor aria-label="4.2.3 HashMap(int initialCapacity, float loadFactor)">4.2.3 HashMap(int initialCapacity, float loadFactor)</a></li>
<li>
<a href=#424-hashmapmap-extends-k--extends-v-m--%e4%ba%86%e8%a7%a3 aria-label="4.2.4 HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m)  了解">4.2.4 HashMap(Map&lt;? extends K, ? extends V> m) 了解</a></li></ul>
</ul>
</li>
<li>
<a href=#43-%e6%88%90%e5%91%98%e6%96%b9%e6%b3%95 aria-label="4.3 成员方法">4.3 成员方法</a><ul>
<ul>
<li>
<a href=#431-%e5%a2%9e%e5%8a%a0%e6%96%b9%e6%b3%95-put-%e9%87%8d%e7%82%b9 aria-label="4.3.1 增加方法 put() (重点)">4.3.1 增加方法 put() (重点)</a></li>
<li>
<a href=#432-%e5%b0%86%e9%93%be%e8%a1%a8%e8%bd%ac%e6%8d%a2%e4%b8%ba%e7%ba%a2%e9%bb%91%e6%a0%91-treeifybin-%e4%ba%86%e8%a7%a3 aria-label="4.3.2 将链表转换为红黑树 treeifyBin() (了解)">4.3.2 将链表转换为红黑树 treeifyBin() (了解)</a></li>
<li>
<a href=#433-%e6%89%a9%e5%ae%b9%e6%96%b9%e6%b3%95-resize-%e9%87%8d%e7%82%b9 aria-label="4.3.3 扩容方法 resize() (重点)">4.3.3 扩容方法 resize() (重点)</a></li>
<li>
<a href=#435-%e6%9f%a5%e6%89%be%e5%85%83%e7%b4%a0%e6%96%b9%e6%b3%95-get-%e9%87%8d%e7%82%b9 aria-label="4.3.5 查找元素方法 get() (重点)">4.3.5 查找元素方法 get() (重点)</a></li>
<li>
<a href=#436-%e9%81%8d%e5%8e%86-hashmap-%e9%9b%86%e5%90%88%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f aria-label="4.3.6 遍历 HashMap 集合几种方式">4.3.6 遍历 HashMap 集合几种方式</a></li></ul>
</ul>
</li></ul>
</li>
<li>
<a href=#%e4%ba%94%e8%ae%be%e8%ae%a1-hashmap-%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e5%ae%b9%e9%87%8f aria-label="五、设计 HashMap 的初始化容量">五、设计 HashMap 的初始化容量</a><ul>
<li>
<a href=#51-%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0 aria-label="5.1 问题描述">5.1 问题描述</a></li>
<li>
<a href=#52-%e9%98%bf%e9%87%8c%e5%b7%b4%e5%b7%b4java%e5%bc%80%e5%8f%91%e6%89%8b%e5%86%8c%e7%9a%84%e5%bb%ba%e8%ae%ae aria-label="5.2 《阿里巴巴Java开发手册》的建议">5.2 《阿里巴巴Java开发手册》的建议</a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h3 id=一hashmap-集合简介>一、HashMap 集合简介<a hidden class=anchor aria-hidden=true href=#一hashmap-集合简介>#</a></h3>
<ul>
<li>
<p><strong>HashMap 基于 哈希表</strong> (是根据关键码值(Key value)而直接进行访问的数据结构) <strong>的 Map 接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null，此外，HashMap 中的映射不是有序的。</strong></p>
</li>
<li>
<p>jdk1.8 之前 HashMap 由 <strong>数组 + 链表</strong> 组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突（<strong>两个对象调用的 hashCode 方法计算的哈希值一致导致计算的教组索引值相同</strong>）而存在的（“拉链法”解决冲突）。jdk1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8 ）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></p>
</li>
<li>
<p><strong>补充：将链表转换成红黑树前会判断，即便阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树，而是选择逬行数组扩容。</strong></p>
<p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层阈值大于8并且数组长度大于64时，链表才转换为红黑树，具体可以参考 treeifyBin() 方法。</p>
<p>当然,虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。</p>
</li>
<li>
<p>小结：</p>
<p>HashMap 特点：</p>
<ol>
<li>存储无序的。</li>
<li>键和值位置都可以是 null，但是键位置只能存在一个 null。</li>
<li>键位置是唯一的，是底层的数据结构控制的。</li>
<li>jdk1.8 前数据结构是<strong>链表+数组</strong>，jdk1.8 之后是<strong>链表+数组+红黑树</strong>。</li>
<li>阈值（边界值）> 8 并且数组长度大于 64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</li>
</ol>
</li>
</ul>
<h3 id=二hashmap-集合底层的数据结构>二、HashMap 集合底层的数据结构<a hidden class=anchor aria-hidden=true href=#二hashmap-集合底层的数据结构>#</a></h3>
<h4 id=21数据结构概念>2.1数据结构概念<a hidden class=anchor aria-hidden=true href=#21数据结构概念>#</a></h4>
<p>数据结构是[计算机]存储、组织[数据]的方式。数据结构是指相互之间存在一种或多种特定关系的[数据元素]的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储[效率]。数据结构往往同高效的检索[算法]和[索引]技术有关。</p>
<p>数据结构:就是存储数据的一种方式;</p>
<h4 id=22-存储数据的过程>2.2 存储数据的过程<a hidden class=anchor aria-hidden=true href=#22-存储数据的过程>#</a></h4>
<p>示例代码：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>map</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>
<span class=n>map</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;柳岩&#34;</span><span class=o>,</span> <span class=n>18</span><span class=o>);</span>
<span class=n>map</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;杨幂&#34;</span><span class=o>,</span> <span class=n>28</span><span class=o>);</span>
<span class=n>map</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;刘德华&#34;</span><span class=o>,</span> <span class=n>40</span><span class=o>);</span>
<span class=n>map</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;柳岩&#34;</span><span class=o>,</span> <span class=n>20</span><span class=o>);</span>
</code></pre></div><p>输出结果：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=o>{</span><span class=n>杨幂</span><span class=o>=</span><span class=n>28</span><span class=o>,</span> <span class=n>柳岩</span><span class=o>=</span><span class=n>20</span><span class=o>,</span> <span class=n>刘德华</span><span class=o>=</span><span class=n>40</span><span class=o>}</span>
</code></pre></div><p>分析：</p>
<ol>
<li>
<p>当创建 HashMap 集合对象的时候，在 jdk1.8 之前，构造方法中创建一个长度是16的 Entry[] table 用来存储键值对数据的。在 jdk1.8 以后不是在 HashMap 的构造方法底层创建数组了，是在第一次调用 put 方法时创建的数组 Node[] table 用来存储键值对数据。</p>
</li>
<li>
<p>假设向哈希表中存储 &lt;柳岩,18> 数据，根据柳岩调用 String 类中重写之后的 hashCode() 方法计算出值，然后结合数组长度采用某种算法计算出向 Node 数组中存储数据的空间的索引值。如果计算出的索引空间没有数据，则直接将&lt;柳岩,18>存储到数组中。（举例：计算出的索引是 3 ）</p>
</li>
<li>
<p>向哈希表中存储数据 &lt;刘德华,40>，假设算出的 hashCode() 方法结合数组长度计算出的索引值也是3，那么此时数组空间不是 null，此时底层会比较柳岩和刘德华的 hash 值是否一致，如果不一致，则在空间上划出一个结点来存储键值对数据对 &lt;刘德华,40>，这种方式称为拉链法。</p>
</li>
<li>
<p>假设向哈希表中存储数据 &lt;柳岩,20>，那么首先根据柳岩调用 hashCode() 方法结合数组长度计算出索引是 3，此时比较后存储的数据柳岩和已经存在的数据的 hash 值是否相等，如果 hash 值相等，此时发生哈希碰撞。那么底层会调用柳岩所属类 String 中的 equals() 方法比较两个key的内容是否相等：</p>
<p>相等：将后添加的数据的 value 覆盖之前的 value。</p>
<p>不相等：继续向下和其他的数据的 key 进行比较，如果都不相等，则划出一个结点存储数据，如果结点长度即链表长度大于阈值 8 并且数组长度大于 64 则将链表变为红黑树。
<img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-4.webp alt>
</p>
</li>
<li>
<p>在不断的添加数据的过程中，会涉及到扩容问题，当超出阈值（且要存放的位置非空）时，扩容。默认的扩容方式：扩容为原来容量的 2 倍，并将原有的数据复制过来。</p>
</li>
<li>
<p>综上描述，当位于一个表中的元素较多，即 hash 值相等但是内容不相等的元素较多时，通过 key 值依次查找的效率较低。而 jdk1.8 中，哈希表存储采用数组+链表+红黑树实现，当链表长度（阈值）超过8且当前数组的长度大于64时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示：
<img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-5.webp alt>
</p>
</li>
<li>
<p>jdk1.8 中引入红黑树的进一步原因：</p>
<p>jdk1.8以前 HashMap 的实现是数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当HashMap中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有n个元素，遍历的时间复杂度就是O(n)，完全失去了它的优势。</p>
<p>针对这种情况，jdk1.8中引入了红黑树（查找时间复杂度为O(logn)）来优化这个问题。当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p>
<p>关于时间复杂度O(n),O(logn)简介,参考:https://www.jianshu.com/p/f31744e423eb</p>
</li>
<li>
<p>总结：</p>
</li>
</ol>
<p><img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-6.webp alt>
说明：</p>
<ul>
<li>size 表示 HashMap 中键值对的实时数量，注意这个不等于数组的长度。</li>
<li>threshold（临界值）= capacity（容量）* loadFactor（负载因子）。这个值是当前已占用数组长度的最大值。size超过这个值就重新 resize（扩容），扩容后的 HashMap 容量是之前容量的两倍。</li>
</ul>
<h4 id=23-面试题>2.3 面试题<a hidden class=anchor aria-hidden=true href=#23-面试题>#</a></h4>
<ol>
<li><strong>HashMap 中 hash 函数是怎么实现的？还有哪些hash函数的实现方式？</strong>
答：对于 key 的 hashCode 做 hash 操作，无符号右移 16 位然后做异或运算。还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移 16 位异或运算效率是最高的。</li>
<li><strong>什么是哈希碰撞，如何解决哈希碰撞？</strong>
答：只要两个元素的 key 计算的哈希码值相同就会发生哈希碰撞。jdk8 之前使用链表解决哈希碰撞。jdk8之后使用链表 + 红黑树解决哈希碰撞。</li>
<li><strong>如果两个键的 hashCode 相同，如何存储键值对？</strong>
答：通过 equals 比较内容是否相同。相同：则新的 value 覆盖之前的 value。不相同：则将新的键值对添加到到链表后面，链表长度超过阈值 8 且数组长度超过64就转换为红黑树存储。</li>
</ol>
<h3 id=三hashmap继承关系>三、HashMap继承关系<a hidden class=anchor aria-hidden=true href=#三hashmap继承关系>#</a></h3>
<p>HashMap继承关系如下图所示：</p>
<p><img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-7.webp alt>
<strong>说明</strong>：</p>
<ul>
<li>Cloneable 空接口，表示可以克隆。创建并返回 HashMap 对象的一个副本。</li>
<li>Serializable 序列化接口。属于标记性接口。HashMap 对象可以被序列化和反序列化。</li>
<li>AbstractMap 父类提供了 Map 实现接口。以最大限度地减少实现此接口所需的工作。</li>
</ul>
<p><strong>补充</strong>：</p>
<p>通过上述继承关系我们发现一个很奇怪的现象，就是 HashMap 已经继承了AbstractMap 而 AbstractMap 类实现了Map 接口，那为什么 HashMap 还要在实现 Map 接口呢？同样在 ArrayList 中 LinkedLis 中都是这种结构。</p>
<p>据 Java 集合框架的创始人 Josh Bloch 描述，这样的写法是一个失误。在 Java 集合框架中，类似这样的写法很多，最幵始写 Java 集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，jdk 的维护者，后来不认为这个小小的失误值得去修改，所以就这样保留下来了。</p>
<h3 id=四hashmap-集合类的成员>四、HashMap 集合类的成员<a hidden class=anchor aria-hidden=true href=#四hashmap-集合类的成员>#</a></h3>
<h4 id=41-成员变量>4.1 成员变量<a hidden class=anchor aria-hidden=true href=#41-成员变量>#</a></h4>
<h6 id=411--serialversionuid>4.1.1 serialVersionUID<a hidden class=anchor aria-hidden=true href=#411--serialversionuid>#</a></h6>
<p>序列化版本号</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>long</span> <span class=n>serialVersionUID</span> <span class=o>=</span> <span class=n>362498820763181265L</span><span class=o>;</span>

</code></pre></div><h6 id=412--default_load_factor>4.1.2 DEFAULT_LOAD_FACTOR<a hidden class=anchor aria-hidden=true href=#412--default_load_factor>#</a></h6>
<p>默认的负载因子</p>
<p>（默认值 0.75）</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kd>final</span> <span class=kt>float</span> <span class=n>DEFAULT_LOAD_FACTOR</span> <span class=o>=</span> <span class=n>0</span><span class=o>.</span><span class=na>75f</span><span class=o>;</span>

</code></pre></div><h6 id=413-maximum_capacity>4.1.3 MAXIMUM_CAPACITY<a hidden class=anchor aria-hidden=true href=#413-maximum_capacity>#</a></h6>
<p>集合最大容量</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>=</span> <span class=n>1</span> <span class=o>&lt;&lt;</span> <span class=n>30</span><span class=o>;</span> <span class=c1>// 2的30次幂
</span><span class=c1></span>
</code></pre></div><h6 id=414-untreeify_threshold>4.1.4 UNTREEIFY_THRESHOLD<a hidden class=anchor aria-hidden=true href=#414-untreeify_threshold>#</a></h6>
<p>当链表的值小于 6 则会从红黑树转回链表</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 当桶（bucket）上的结点数小于这个值，树转为链表 
</span><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>UNTREEIFY_THRESHOLD</span> <span class=o>=</span> <span class=n>6</span><span class=o>;</span>

</code></pre></div><h6 id=415-min_treeify_capacity>4.1.5 MIN_TREEIFY_CAPACITY<a hidden class=anchor aria-hidden=true href=#415-min_treeify_capacity>#</a></h6>
<p>当 Map 里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于4*TREEIFY_THRESHOLD(8)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 桶中结构转化为红黑树对应的数组长度最小的值 
</span><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>MIN_TREEIFY_CAPACITY</span> <span class=o>=</span> <span class=n>64</span><span class=o>;</span>

</code></pre></div><h6 id=416-entryset>4.1.6 entrySet<a hidden class=anchor aria-hidden=true href=#416-entryset>#</a></h6>
<p>用来存放缓存</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 存放具体元素的集合
</span><span class=c1></span><span class=kd>transient</span> <span class=n>Set</span><span class=o>&lt;</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;&gt;</span> <span class=n>entrySet</span><span class=o>;</span>

</code></pre></div><h6 id=417-size>4.1.7 size<a hidden class=anchor aria-hidden=true href=#417-size>#</a></h6>
<p>HashMap 中存放元素的个数(重点)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 存放元素的个数，注意这个不等于数组的长度
</span><span class=c1></span> <span class=kd>transient</span> <span class=kt>int</span> <span class=n>size</span><span class=o>;</span>

</code></pre></div><p>size 为 HashMap 中 K-V 的实时数量，不是数组 table 的长度。</p>
<h6 id=418-modcount>4.1.8 modCount<a hidden class=anchor aria-hidden=true href=#418-modcount>#</a></h6>
<p>用来记录 HashMap 的修改次数</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 每次扩容和更改 map 结构的计数器
</span><span class=c1></span> <span class=kd>transient</span> <span class=kt>int</span> <span class=n>modCount</span><span class=o>;</span>  

</code></pre></div><h6 id=419-threshold>4.1.9 threshold<a hidden class=anchor aria-hidden=true href=#419-threshold>#</a></h6>
<p>临界值</p>
<p>用来调整大小下一个容量的值计算方式为（容量*负载因子）</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 临界值 当实际大小（容量*负载因子）超过临界值时，会进行扩容
</span><span class=c1></span><span class=kt>int</span> <span class=n>threshold</span><span class=o>;</span>

</code></pre></div><h6 id=4110-default_initial_capacity>4.1.10 DEFAULT_INITIAL_CAPACITY<a hidden class=anchor aria-hidden=true href=#4110-default_initial_capacity>#</a></h6>
<p>集合的初始化容量（必须是 2 的 n 次幂）</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 默认的初始容量是16	1 &lt;&lt; 4 相当于 1*2的4次方
</span><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span> <span class=o>=</span> <span class=n>1</span> <span class=o>&lt;&lt;</span> <span class=n>4</span><span class=o>;</span>

</code></pre></div><p><strong>问题：初始化容量为什么必须是 2 的 n 次幂？</strong></p>
<p>HashMap 构造方法还可以指定集合的初始化容量大小：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 构造一个带指定初始容量和默认负载因子（0.75)的空 HashMap。
</span><span class=c1></span><span class=n>HashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>)</span>

</code></pre></div><p>因为当向 HashMap 中添加一个元素的时候，需要根据 key 的 hash 值，去确定其在数组中的具体位置。<em><strong>HashMap 为了存取高效，减少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现的关键就在于把数据存到哪个链表中的算法。</strong></em></p>
<p>这个算法实际就是取模，hash % length，计算机中直接求余效率不如位移运算。所以源码中做了优化，使用 hash & (length - 1)，而实际上 hash % length 等于 hash & ( length - 1) ,所以前提必须是 length 是 2 的 n 次幂。</p>
<p><strong>问题又来了：为什么这样就能均匀分布减少碰撞呢?</strong></p>
<p>举例:</p>
<p><strong>说明:按位与运算规则:相同的二进制数位上,都是1的时候,结果为1.否则为0;</strong></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=nl>例如:</span> <span class=n>如果数组长度是2的次幂</span>
<span class=n>hash</span> <span class=o>:</span> <span class=n>3</span>  <span class=n>length数组长度</span> <span class=o>:</span> <span class=n>8</span><span class=o>(</span><span class=n>是</span><span class=o>)</span>

<span class=n>3</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>8</span><span class=o>-</span><span class=n>1</span><span class=o>)</span>

<span class=n>00000011</span>  <span class=n>3</span>
<span class=n>00000111</span>  <span class=n>7</span>
<span class=o>------------</span>
<span class=n>00000011</span>  <span class=n>3</span>  <span class=n>索引</span>


<span class=n>hash</span> <span class=o>:</span> <span class=n>2</span>  <span class=n>length数组长度</span> <span class=o>:</span> <span class=n>8</span><span class=o>(</span><span class=n>是</span><span class=o>)</span>

<span class=n>2</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>8</span><span class=o>-</span><span class=n>1</span><span class=o>)</span>

<span class=n>00000010</span>  <span class=n>2</span>
<span class=n>00000111</span>  <span class=n>7</span>
<span class=o>------------</span>
<span class=n>00000010</span>  <span class=n>2</span>  <span class=n>索引</span>

<span class=o>===============================================================</span>
<span class=nl>
</span><span class=nl>例如:</span> <span class=n>如果数组长度不是2的次幂</span>
<span class=n>hash</span> <span class=o>:</span> <span class=n>3</span>  <span class=n>length数组长度</span> <span class=o>:</span> <span class=n>9</span><span class=o>(</span><span class=n>不是</span><span class=o>)</span>

<span class=n>3</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>9</span><span class=o>-</span><span class=n>1</span><span class=o>)</span>

<span class=n>00000011</span>  <span class=n>3</span>
<span class=n>00001000</span>  <span class=n>8</span>
<span class=o>------------</span>
<span class=n>00000000</span>  <span class=n>0</span>  <span class=n>索引</span>


<span class=n>hash</span> <span class=o>:</span> <span class=n>2</span>  <span class=n>length数组长度</span> <span class=o>:</span> <span class=n>9</span><span class=o>(</span><span class=n>不是</span><span class=o>)</span>

<span class=n>2</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>9</span><span class=o>-</span><span class=n>1</span><span class=o>)</span>

<span class=n>00000010</span>  <span class=n>2</span>
<span class=n>00001000</span>  <span class=n>8</span>
<span class=o>------------</span>
<span class=n>00000000</span>  <span class=n>0</span>  <span class=n>索引</span>
</code></pre></div><p>总结:如果数组长度不是2的次幂,计算出的索引特别容易相同,及其容易发生hash碰撞,导致其余数组空间很大程度上并没有存储数据,链表或者红黑树过长,效率降低.</p>
<p><strong>问题：如果初始容量不设置2的次幂,比如10呢?</strong></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/**
</span><span class=cm>* Returns a power of two size for the given target capacity.
</span><span class=cm>*/</span>
<span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>tableSizeFor</span><span class=o>(</span><span class=kt>int</span> <span class=n>cap</span><span class=o>)</span> <span class=o>{</span><span class=c1>//10
</span><span class=c1></span>  <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>cap</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>1</span><span class=o>;</span>
  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>2</span><span class=o>;</span>
  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>4</span><span class=o>;</span>
  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>8</span><span class=o>;</span>
  <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=o>;</span>
  <span class=k>return</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>?</span> <span class=n>1</span> <span class=o>:</span> <span class=o>(</span><span class=n>n</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>?</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>:</span> <span class=n>n</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
<span class=o>}</span>


<span class=o>|</span>   <span class=n>按位或运算规则</span><span class=o>:</span> <span class=n>相同的二进制数位上</span><span class=o>,</span><span class=n>都是0的时候</span><span class=o>,</span><span class=n>结果为0</span><span class=o>.</span><span class=na>否则为1</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>无符号右移</span>  
</code></pre></div><p><strong>说明</strong>：</p>
<p>当在实例化 HashMap 实例时，如果给定了 initialCapacity，由于 HashMap 的 capacity 必须都是 2 的次幂，因此这个方法用于找到大于等于 initialCapacity 的最小的 2 的幂。</p>
<p><strong>分析</strong>：</p>
<p>int n = cap - 1;
防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂，又没有这个减 1 操作，则执行完后面的几条无符号操作之后，返回的 capacity 将是这个 cap 的 2 倍。</p>
<p><strong>完整例子</strong>：</p>
<p><img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-8.webp alt>
注意：得到的这个 capacity(容量) 却被赋值给了 threshold(临界值(容量*负载因子))。</p>
<p>思考一下: capacity 被赋值给了 threshold这样有没有问题?后面讲解</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=k>this</span><span class=o>.</span><span class=na>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>);</span>

</code></pre></div><h6 id=4111-treeify_threshold>4.1.11 TREEIFY_THRESHOLD<a hidden class=anchor aria-hidden=true href=#4111-treeify_threshold>#</a></h6>
<p>当链表的值超过8则会转为红黑树（jdk1.8新增）</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 当桶（bucket）上的结点数大于这个值时会转为红黑树
</span><span class=c1></span><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>TREEIFY_THRESHOLD</span> <span class=o>=</span> <span class=n>8</span><span class=o>;</span>

</code></pre></div><p><strong>问题：为什么 Map 桶中结点个数超过 8 才转为红黑树？</strong></p>
<p>我们都知道，链表的时间复杂度是O(n)，红黑树的时间复杂度O(logn)，很显然，红黑树的复杂度是优于链表的，既然这么棒，那为什么hashmap为什么不直接就用红黑树呢?请看下图</p>
<p>在 HashMap 中有一段注释说明：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=n>Because</span> <span class=n>TreeNodes</span> <span class=n>are</span> <span class=n>about</span> <span class=n>twice</span> <span class=n>the</span> <span class=n>size</span> <span class=n>of</span> <span class=n>regular</span> <span class=n>nodes</span><span class=o>,</span> <span class=n>we</span> <span class=n>use</span> <span class=n>them</span> <span class=n>only</span> <span class=n>when</span> <span class=n>bins</span>
<span class=n>contain</span> <span class=n>enough</span> <span class=n>nodes</span> <span class=n>to</span> <span class=n>warrant</span> <span class=nf>use</span> <span class=o>(</span><span class=n>see</span> <span class=n>TREEIFY_THRESHOLD</span><span class=o>).</span> <span class=n>And</span> <span class=n>when</span> <span class=n>they</span> <span class=n>become</span> <span class=n>too</span>
<span class=nf>small</span> <span class=o>(</span><span class=n>due</span> <span class=n>to</span> <span class=n>removal</span> <span class=n>or</span> <span class=n>resizing</span><span class=o>)</span> <span class=n>they</span> <span class=n>are</span> <span class=n>converted</span> <span class=n>back</span> <span class=n>to</span> <span class=n>plain</span> <span class=n>bins</span><span class=o>.</span>  <span class=n>In</span> <span class=n>usages</span> <span class=n>with</span>
<span class=n>well</span><span class=o>-</span><span class=n>distributed</span> <span class=n>user</span> <span class=n>hashCodes</span><span class=o>,</span> <span class=n>tree</span> <span class=n>bins</span> <span class=n>are</span> <span class=n>rarely</span> <span class=n>used</span><span class=o>.</span>  <span class=n>Ideally</span><span class=o>,</span> <span class=n>under</span> <span class=n>random</span> <span class=n>hashCodes</span><span class=o>,</span> 
<span class=n>the</span> <span class=n>frequency</span> <span class=n>of</span> <span class=n>nodes</span> <span class=n>in</span> <span class=n>bins</span> <span class=n>follows</span> <span class=n>a</span> <span class=n>Poisson</span> <span class=nf>distribution</span> 
<span class=o>(</span><span class=n>http</span><span class=o>:</span><span class=c1>//en.wikipedia.org/wiki/Poisson_distribution) 
</span><span class=c1></span><span class=n>with</span> <span class=n>a</span> <span class=n>parameter</span> <span class=n>of</span> <span class=n>about</span> <span class=n>0</span><span class=o>.</span><span class=na>5</span> <span class=n>on</span> <span class=n>average</span> <span class=k>for</span> <span class=n>the</span> <span class=k>default</span> <span class=n>resizing</span>
<span class=n>threshold</span> <span class=n>of</span> <span class=n>0</span><span class=o>.</span><span class=na>75</span><span class=o>,</span> <span class=n>although</span> <span class=n>with</span> <span class=n>a</span> <span class=n>large</span> <span class=n>variance</span> <span class=n>because</span> <span class=n>of</span> <span class=n>resizing</span> <span class=n>granularity</span><span class=o>.</span> <span class=n>Ignoring</span> <span class=n>variance</span><span class=o>,</span> 
<span class=n>the</span> <span class=n>expected</span> <span class=n>occurrences</span> <span class=n>of</span> <span class=n>list</span> <span class=n>size</span> <span class=n>k</span> <span class=nf>are</span> <span class=o>(</span><span class=n>exp</span><span class=o>(-</span><span class=n>0</span><span class=o>.</span><span class=na>5</span><span class=o>)</span> <span class=o>*</span> <span class=n>pow</span><span class=o>(</span><span class=n>0</span><span class=o>.</span><span class=na>5</span><span class=o>,</span> <span class=n>k</span><span class=o>)</span> <span class=o>/</span> <span class=n>factorial</span><span class=o>(</span><span class=n>k</span><span class=o>)).</span> <span class=n>The</span> <span class=n>first</span> <span class=n>values</span> <span class=n>are</span><span class=o>:</span>

<span class=n>翻译</span><span class=err>：</span><span class=n>因为树结点的大小大约是普通结点的两倍</span><span class=err>，</span><span class=n>所以我们只在箱子包含足够的结点时才使用树结点</span><span class=o>(</span><span class=n>参见TREEIFY_THRESHOLD</span><span class=o>)</span><span class=err>。</span>
<span class=n>当它们变得太小</span><span class=err>（</span><span class=n>由于删除或调整大小</span><span class=err>）</span><span class=n>时</span><span class=err>，</span><span class=n>就会被转换回普通的桶</span><span class=err>。</span><span class=n>在使用分布良好的用户</span> <span class=n>hashCode</span> <span class=n>时</span><span class=err>，</span><span class=n>很少使用树箱</span><span class=err>。</span>
<span class=n>理想情况下</span><span class=err>，</span><span class=n>在随机哈希码下</span><span class=err>，</span><span class=n>箱子中结点的频率服从泊松分布</span>
<span class=o>(</span><span class=n>http</span><span class=o>:</span><span class=c1>//en.wikipedia.org/wiki/Poisson_distribution) ，默认调整阈值为0.75，平均参数约为0.5，尽管由 
</span><span class=c1></span><span class=n>于调整粒度的差异很大</span><span class=err>。</span><span class=n>忽略方差</span><span class=err>，</span><span class=n>列表大小k的预朗出现次数是</span><span class=o>(</span><span class=n>exp</span><span class=o>(-</span><span class=n>0</span><span class=o>.</span><span class=na>5</span><span class=o>)</span> <span class=o>*</span> <span class=n>pow</span><span class=o>(</span><span class=n>0</span><span class=o>.</span><span class=na>5</span><span class=o>,</span> <span class=n>k</span><span class=o>)</span> <span class=o>/</span> <span class=n>factorial</span><span class=o>(</span><span class=n>k</span><span class=o>))</span><span class=err>。</span> 
<span class=n>第一个值是</span><span class=err>：</span>
<span class=nl>
</span><span class=nl>0:</span>    <span class=n>0</span><span class=o>.</span><span class=na>60653066</span>
<span class=nl>1:</span>    <span class=n>0</span><span class=o>.</span><span class=na>30326533</span>
<span class=nl>2:</span>    <span class=n>0</span><span class=o>.</span><span class=na>07581633</span>
<span class=nl>3:</span>    <span class=n>0</span><span class=o>.</span><span class=na>01263606</span>
<span class=nl>4:</span>    <span class=n>0</span><span class=o>.</span><span class=na>00157952</span>
<span class=nl>5:</span>    <span class=n>0</span><span class=o>.</span><span class=na>00015795</span>
<span class=nl>6:</span>    <span class=n>0</span><span class=o>.</span><span class=na>00001316</span>
<span class=nl>7:</span>    <span class=n>0</span><span class=o>.</span><span class=na>00000094</span>
<span class=nl>8:</span>    <span class=n>0</span><span class=o>.</span><span class=na>00000006</span>
<span class=nl>more:</span> <span class=n>less</span> <span class=n>than</span> <span class=n>1</span> <span class=n>in</span> <span class=n>ten</span> <span class=n>million</span>

</code></pre></div><p>源码中的注释写的很清楚，因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。</p>
<p>为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点遵循泊松分布，而且根据统计，链表中节点数是8的概率已经接近千万分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。</p>
<p>综上所述,我们可以看到，一个 桶 中链表长度达到 8 个元素的槪率为 0.00000006，几乎是不可能事件。所以，之所以选择 8，不是随便決定的，而是裉据概率统计决定的。甶此可见，发展将近30年的 Java 每一项改动和优化都是非常严谨和科学的。</p>
<p><strong>也就是说：选择 8 因为符合泊松分布，超过 8 的时候，概率已经非常小了，所以我们选择 8 这个数宇。</strong></p>
<ul>
<li>
<p>以下是在一些资料上面翻看的解释，供大家参考：</p>
<p>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8) = 3，链表的平均查找长度为 n/2，当长度为 8 时，平均查找长虔为 8/2 = 4，这才有转换成树的必要；链表长度如果是小于等于 6， 6/2 = 3，而 log(6) = 2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</p>
</li>
</ul>
<h6 id=4112-table>4.1.12 table<a hidden class=anchor aria-hidden=true href=#4112-table>#</a></h6>
<p>table 用来初始化（必须是2的n次幂）(重点)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 存储元素的数组 
</span><span class=c1></span><span class=kd>transient</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>table</span><span class=o>;</span>

</code></pre></div><p>在 jdk1.8 中我们了解到 HashMap 是由数组加链表加红黑树来组成的结构，其中 table 就是 HashMap 中的数组，jdk8 之前数组类型是 Entry&lt;K,V> 类型。从 jdk1.8 之后是 Node&lt;K,V> 类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V>。负责存储键值对数据的。</p>
<h6 id=4113-loadfactor>4.1.13 loadFactor<a hidden class=anchor aria-hidden=true href=#4113-loadfactor>#</a></h6>
<p>负载因子,哈希表的负载因子(重点)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 负载因子
</span><span class=c1></span><span class=kd>final</span> <span class=kt>float</span> <span class=n>loadFactor</span><span class=o>;</span>

</code></pre></div><p><strong>说明</strong>：</p>
<ul>
<li>loadFactor 是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响 hash 操作到同一个数组位置的概率</strong></li>
<li>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</li>
<li>当 HashMap 里面容纳的元素已经达到 HashMap 数组长度的 75% 时，表示 HashMap 太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。所以开发中尽量减少扩容的次数，可以通过创建 HashMap 集合对象时指定初始容量来尽量避免。</li>
<li>在 HashMap 的构造器中可以定制 loadFactor。</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 构造方法，构造一个带指定初始容量和负载因子的空HashMap
</span><span class=c1></span><span class=n>HashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>,</span> <span class=kt>float</span> <span class=n>loadFactor</span><span class=o>);</span>

</code></pre></div><ul>
<li>
<p>为什么负载因子设置为0.75，初始化临界值是12？</p>
<p>loadFactor 越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，</p>
<p>loadFactor 越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-9.webp alt>
如果希望链表尽可能少些，要提前扩容。有的数组空间有可能一直没有存储数据，负载因子尽可能小一些。</p>
</li>
</ul>
<p>举例：</p>
<pre tabindex=0><code>例如：负载因子是0.4。 那么16*0.4---&gt;6 如果数组中满6个空间就扩容会造成数组利用率太低了。
	 负载因子是0.9。 那么16*0.9---&gt;14 那么这样就会导致链表有点多了，导致查找元素效率低。

</code></pre><p>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试 0.75 是最佳方案。</p>
<ul>
<li>
<p><strong>threshold</strong> 计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。</p>
<p>这个值是当前已占用数组长度的最大值。当 <strong>Size >= threshold</strong> 的时候，那么就要考虑对数组的 resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍。</p>
</li>
</ul>
<h4 id=42-构造方法>4.2 构造方法<a hidden class=anchor aria-hidden=true href=#42-构造方法>#</a></h4>
<p>HashMap 中重要的构造方法，它们分别如下：</p>
<h6 id=421-hashmap>4.2.1 HashMap()<a hidden class=anchor aria-hidden=true href=#421-hashmap>#</a></h6>
<p>构造一个空的HashMap，默认初始容量（16）和默认负载因子（0.75）。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=nf>HashMap</span><span class=o>()</span> <span class=o>{</span>
   <span class=k>this</span><span class=o>.</span><span class=na>loadFactor</span> <span class=o>=</span> <span class=n>DEFAULT_LOAD_FACTOR</span><span class=o>;</span> <span class=c1>// 将默认的负载因子0.75赋值给loadFactor，并没有创建数组
</span><span class=c1></span><span class=o>}</span>

</code></pre></div><h6 id=422-hashmapint-initialcapacity>4.2.2 HashMap(int initialCapacity)<a hidden class=anchor aria-hidden=true href=#422-hashmapint-initialcapacity>#</a></h6>
<p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap 。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java> <span class=c1>// 指定“容量大小”的构造函数
</span><span class=c1></span><span class=kd>public</span> <span class=nf>HashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>this</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>,</span> <span class=n>DEFAULT_LOAD_FACTOR</span><span class=o>);</span>
<span class=o>}</span>

</code></pre></div><h6 id=423-hashmapint-initialcapacity-float-loadfactor>4.2.3 HashMap(int initialCapacity, float loadFactor)<a hidden class=anchor aria-hidden=true href=#423-hashmapint-initialcapacity-float-loadfactor>#</a></h6>
<p>构造一个具有指定的初始容量和负载因子的 HashMap。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/*
</span><span class=cm>	 指定“容量大小”和“负载因子”的构造函数
</span><span class=cm>	 initialCapacity：指定的容量
</span><span class=cm>	 loadFactor:指定的负载因子
</span><span class=cm>*/</span>
<span class=kd>public</span> <span class=nf>HashMap</span><span class=o>(</span><span class=kt>int</span> <span class=n>initialCapacity</span><span class=o>,</span> <span class=kt>float</span> <span class=n>loadFactor</span><span class=o>)</span> <span class=o>{</span>
    	<span class=c1>// 判断初始化容量initialCapacity是否小于0
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span>
            <span class=c1>// 如果小于0，则抛出非法的参数异常IllegalArgumentException
</span><span class=c1></span>            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Illegal initial capacity: &#34;</span> <span class=o>+</span> <span class=n>initialCapacity</span><span class=o>);</span>
    	<span class=c1>// 判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>initialCapacity</span> <span class=o>&gt;</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span>
            <span class=c1>// 如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity
</span><span class=c1></span>            <span class=n>initialCapacity</span> <span class=o>=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>;</span>
    	<span class=c1>// 判断负载因子loadFactor是否小于等于0或者是否是一个非数值
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>loadFactor</span> <span class=o>&lt;=</span> <span class=n>0</span> <span class=o>||</span> <span class=n>Float</span><span class=o>.</span><span class=na>isNaN</span><span class=o>(</span><span class=n>loadFactor</span><span class=o>))</span>
            <span class=c1>// 如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException
</span><span class=c1></span>            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Illegal load factor: &#34;</span> <span class=o>+</span> <span class=n>loadFactor</span><span class=o>);</span>
     	<span class=c1>// 将指定的负载因子赋值给HashMap成员变量的负载因子loadFactor
</span><span class=c1></span>        <span class=k>this</span><span class=o>.</span><span class=na>loadFactor</span> <span class=o>=</span> <span class=n>loadFactor</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>);</span>
    <span class=o>}</span>
<span class=c1>// 最后调用了tableSizeFor，来看一下方法实现：
</span><span class=c1></span>     <span class=cm>/*
</span><span class=cm>     	返回比指定初始化容量大的最小的2的n次幂
</span><span class=cm>     */</span>
    <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>tableSizeFor</span><span class=o>(</span><span class=kt>int</span> <span class=n>cap</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>cap</span> <span class=o>-</span> <span class=n>1</span><span class=o>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>1</span><span class=o>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>2</span><span class=o>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>4</span><span class=o>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>8</span><span class=o>;</span>
        <span class=n>n</span> <span class=o>|=</span> <span class=n>n</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=o>;</span>
        <span class=k>return</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>?</span> <span class=n>1</span> <span class=o>:</span> <span class=o>(</span><span class=n>n</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>?</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>:</span> <span class=n>n</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
    <span class=o>}</span>

</code></pre></div><p><strong>说明</strong>：</p>
<p>对于 javathis.threshold = tableSizeFor(initialCapacity); 疑问解答：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=n>tableSizeFor</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>)</span><span class=n>判断指定的初始化容量是否是2的n次幂</span><span class=err>，</span><span class=n>如果不是那么会变为大于等于</span> <span class=n>initialCapacity</span> <span class=n>的最小的</span> <span class=n>2</span> <span class=n>的幂</span><span class=err>。</span>
<span class=n>但是注意</span><span class=err>，</span><span class=n>在tableSizeFor方法体内部将计算后的数据返回给调用这里了</span><span class=err>，</span><span class=n>并且直接赋值给threshold边界值了</span><span class=err>。</span><span class=n>有些人会觉得这里是一个bug</span><span class=err>，</span><span class=n>应该这样书写</span><span class=err>：</span>
<span class=k>this</span><span class=o>.</span><span class=na>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=o>(</span><span class=n>initialCapacity</span><span class=o>)</span> <span class=o>*</span> <span class=k>this</span><span class=o>.</span><span class=na>loadFactor</span><span class=o>;</span>
<span class=n>这样才符合threshold的意思</span><span class=err>（</span><span class=n>当HashMap的size到达threshold这个阈值时会扩容</span><span class=err>）。</span>
<span class=n>但是请注意</span><span class=err>，</span><span class=n>在jdk8以后的构造方法中</span><span class=err>，</span><span class=n>并没有对table这个成员变量进行初始化</span><span class=err>，</span><span class=n>table的初始化被推迟到了put方法中</span><span class=err>，</span><span class=n>在put方法中会对threshold重新计算</span><span class=err>。</span>

</code></pre></div><h6 id=424-hashmapmap-extends-k--extends-v-m--了解>4.2.4 HashMap(Map&lt;? extends K, ? extends V> m) 了解<a hidden class=anchor aria-hidden=true href=#424-hashmapmap-extends-k--extends-v-m--了解>#</a></h6>
<p>包含另一个 “Map” 的构造函数</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 构造一个映射关系与指定 Map 相同的新 HashMap。
</span><span class=c1></span><span class=kd>public</span> <span class=nf>HashMap</span><span class=o>(</span><span class=n>Map</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>K</span><span class=o>,</span> <span class=o>?</span> <span class=kd>extends</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>m</span><span class=o>)</span> <span class=o>{</span>
    	<span class=c1>// 负载因子loadFactor变为默认的负载因子0.75
</span><span class=c1></span>         <span class=k>this</span><span class=o>.</span><span class=na>loadFactor</span> <span class=o>=</span> <span class=n>DEFAULT_LOAD_FACTOR</span><span class=o>;</span>
         <span class=n>putMapEntries</span><span class=o>(</span><span class=n>m</span><span class=o>,</span> <span class=kc>false</span><span class=o>);</span>
 <span class=o>}</span>

</code></pre></div><p>最后调用了 putMapEntries()，来看一下方法实现：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=kt>void</span> <span class=nf>putMapEntries</span><span class=o>(</span><span class=n>Map</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>K</span><span class=o>,</span> <span class=o>?</span> <span class=kd>extends</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>m</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>evict</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>//获取参数集合的长度
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>//判断参数集合的长度是否大于0，说明大于0
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>table</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// 判断table是否已经初始化
</span><span class=c1></span>                <span class=c1>// 未初始化，s为m的实际元素个数
</span><span class=c1></span>                <span class=kt>float</span> <span class=n>ft</span> <span class=o>=</span> <span class=o>((</span><span class=kt>float</span><span class=o>)</span><span class=n>s</span> <span class=o>/</span> <span class=n>loadFactor</span><span class=o>)</span> <span class=o>+</span> <span class=n>1</span><span class=o>.</span><span class=na>0F</span><span class=o>;</span>
                <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=o>((</span><span class=n>ft</span> <span class=o>&lt;</span> <span class=o>(</span><span class=kt>float</span><span class=o>)</span><span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>?</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span><span class=n>ft</span> <span class=o>:</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>);</span>
                <span class=c1>// 计算得到的t大于阈值，则初始化阈值
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=o>)</span>
                    <span class=n>threshold</span> <span class=o>=</span> <span class=n>tableSizeFor</span><span class=o>(</span><span class=n>t</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=c1>// 已初始化，并且m元素个数大于阈值，进行扩容处理
</span><span class=c1></span>        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=o>)</span>
            <span class=n>resize</span><span class=o>();</span>
        <span class=c1>// 将m中的所有元素添加至HashMap中
</span><span class=c1></span>        <span class=k>for</span> <span class=o>(</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>K</span><span class=o>,</span> <span class=o>?</span> <span class=kd>extends</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span> <span class=o>:</span> <span class=n>m</span><span class=o>.</span><span class=na>entrySet</span><span class=o>())</span> <span class=o>{</span>
            <span class=n>K</span> <span class=n>key</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>getKey</span><span class=o>();</span>
            <span class=n>V</span> <span class=n>value</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>getValue</span><span class=o>();</span>
            <span class=n>putVal</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>false</span><span class=o>,</span> <span class=n>evict</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>

</code></pre></div><p><strong>注意</strong>：(了解)</p>
<p>float ft = ((float)s / loadFactor) + 1.0F; 这一行代码中为什么要加 1.0F ？</p>
<p>s/loadFactor 的结果是小数，加 1.0F 与 (int)ft 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数。所以 + 1.0F 是为了获取更大的容量。</p>
<p>例如：原来集合的元素个数是 6 个，那么 6/0.75 是8，是 2 的n次幂，那么新的数组大小就是 8 了。然后原来数组的数据就会存储到长度是 8 的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果 +1 呢，数组长度直接变为16了，这样可以减少数组的扩容。</p>
<h4 id=43-成员方法>4.3 成员方法<a hidden class=anchor aria-hidden=true href=#43-成员方法>#</a></h4>
<h6 id=431-增加方法-put-重点>4.3.1 增加方法 put() (重点)<a hidden class=anchor aria-hidden=true href=#431-增加方法-put-重点>#</a></h6>
<p>put方法是比较复杂的，实现步骤大致如下：</p>
<ol>
<li>
<p>先通过 hash 值计算出 key 映射到哪个桶；</p>
</li>
<li>
<p>如果桶上没有碰撞冲突，则直接插入；</p>
</li>
<li>
<p>如果出现碰撞冲突了，则需要处理冲突：</p>
<p>a 如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；</p>
<p>b 否则采用传统的链式方法插入。如果链的长度达到阈值，则把链转变为红黑树；</p>
</li>
<li>
<p>如果桶中存在重复的键，则为该键替换新值 value；</p>
</li>
<li>
<p>如果 size 大于临界值 threshold，则进行扩容；</p>
</li>
</ol>
<p>具体的方法如下：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=n>V</span> <span class=nf>put</span><span class=o>(</span><span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
	<span class=k>return</span> <span class=n>putVal</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>false</span><span class=o>,</span> <span class=kc>true</span><span class=o>);</span>
<span class=o>}</span>

</code></pre></div><p>说明：</p>
<ol>
<li>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。 所以我们重点看 putVal 方法。</li>
<li>我们可以看到在 putVal 方法中 key 在这里执行了一下 hash 方法,来看一下 hash 方法是如何实现的。</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>hash</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
	<span class=kt>int</span> <span class=n>h</span><span class=o>;</span>
	<span class=cm>/*
</span><span class=cm>	1）如果key等于null：返回的是0.
</span><span class=cm>	2）如果key不等于null：首先计算出key的hashCode赋值给h，然后与h无符号右移16位后的
</span><span class=cm>		二进制进行按位异或得到最后的hash值
</span><span class=cm>	*/</span>
	<span class=k>return</span> <span class=o>(</span><span class=n>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=n>0</span> <span class=o>:</span> <span class=o>(</span><span class=n>h</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>hashCode</span><span class=o>())</span> <span class=o>^</span> <span class=o>(</span><span class=n>h</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=o>);</span>
<span class=o>}</span>

</code></pre></div><p>从上面可以得知 HashMap 是支持 key 为空的，而 HashTable 是直接用 Key 来获取hashCode 所以 key 为空会抛异常。</p>
<p><strong>解读上述 hash 方法</strong>：</p>
<p>我们先研究下 key 的哈希值是如何计算出来的。</p>
<p>这个哈希方法首先计算出 key 的 hashCode 赋值给 h，然后与 h 无符号右移 16 位后的二进制进行按位异或得到最后的 hash 值。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=nf>hash</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
	<span class=kt>int</span> <span class=n>h</span><span class=o>;</span>
	<span class=k>return</span> <span class=o>(</span><span class=n>key</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=n>0</span> <span class=o>:</span> <span class=o>(</span><span class=n>h</span> <span class=o>=</span> <span class=n>key</span><span class=o>.</span><span class=na>hashCode</span><span class=o>())</span> <span class=o>^</span> <span class=o>(</span><span class=n>h</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>16</span><span class=o>);</span>
<span class=o>}</span>

</code></pre></div><p>在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=n>V</span> <span class=nf>putVal</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>onlyIfAbsent</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>evict</span><span class=o>)</span> <span class=o>{</span>
	<span class=o>...</span>
	<span class=k>if</span> <span class=o>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=o>])</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=c1>// 这里的n表示数组长度16
</span><span class=c1></span>	<span class=o>...</span>
<span class=o>}</span>

</code></pre></div><p>计算过程如下所示：</p>
<p><strong>说明</strong>：</p>
<ol>
<li>key.hashCode()；返回散列值也就是 hashcode，假设随便生成的一个值。</li>
<li>n 表示数组初始化的长度是 16。</li>
<li>&（按位与运算）：运算规则：相同的二进制数位上，都是 1 的时候，结果为 1，否则为0。</li>
<li>^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为 0，不同为 1。</li>
</ol>
<p><img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053.webp alt>
简单来说就是：</p>
<p>高 16bit 不变，低 16bit 和高 16bit 做了一个异或（得到的 hashCode 转化为 32 位二进制，前 16 位和后 16 位,低 16bit 和高 16bit 做了一个异或）。</p>
<p><strong>问题：为什么要这样操作呢？</strong></p>
<p>如果当 n 即数组长度很小，假设是 16 的话，那么 n - 1 即为 1111(15的二进制表示) ，这样的值和 hashCode 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p>
<pre tabindex=0><code>假设hashCode值直接和数组长度(n-1)按位与运算

1111 1111 1111 1111 1111 0000 1110 1010     h=key.hashCode()，假设随便生成的一个值。
0000 0000 0000 0000 0000 0000 0000 1111     (16 - 1)
---------------------------------------------------------
0000 0000 0000 0000 0000 0000 0000 1010      10索引


再存储一个key计算出hashCode值:加入高位变化很大,低位没有改变
1001 1001 1001 1111 1111 0000 1110 1010
0000 0000 0000 0000 0000 0000 0000 1111     (16 - 1)
---------------------------------------------------------
0000 0000 0000 0000 0000 0000 0000 1010      10索引
</code></pre><p>现在看 putVal 方法，看看它到底做了什么。</p>
<p>主要参数：</p>
<ul>
<li>hash：key 的 hash 值</li>
<li>key：原始 key</li>
<li>value：要存放的值</li>
<li>onlyIfAbsent：如果 true 代表不更改现有的值</li>
<li>evict：如果为false表示 table 为创建状态</li>
</ul>
<p>putVal 方法源代码如下所示：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=n>V</span> <span class=nf>put</span><span class=o>(</span><span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
	<span class=k>return</span> <span class=n>putVal</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>false</span><span class=o>,</span> <span class=kc>true</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>final</span> <span class=n>V</span> <span class=nf>putVal</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>K</span> <span class=n>key</span><span class=o>,</span> <span class=n>V</span> <span class=n>value</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>onlyIfAbsent</span><span class=o>,</span> <span class=kt>boolean</span> <span class=n>evict</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>tab</span><span class=o>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span><span class=o>;</span> <span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=n>i</span><span class=o>;</span>
    <span class=cm>/*
</span><span class=cm>    	1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。
</span><span class=cm>    	2）(tab = table) == null 表示将空的table赋值给tab，然后判断tab是否等于null，第一次肯定是null。
</span><span class=cm>    	3）(n = tab.length) == 0 表示将数组的长度0赋值给n，然后判断n是否等于0，n等于0，由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化，并将初始化好的数组长度赋值给n。
</span><span class=cm>    	4）执行完n = (tab = resize()).length，数组tab每个空间都是null。
</span><span class=cm>    */</span>
    <span class=k>if</span> <span class=o>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span>
        <span class=n>n</span> <span class=o>=</span> <span class=o>(</span><span class=n>tab</span> <span class=o>=</span> <span class=n>resize</span><span class=o>()).</span><span class=na>length</span><span class=o>;</span>
    <span class=cm>/*
</span><span class=cm>    	1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中。
</span><span class=cm>    	2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给结点p。
</span><span class=cm>    	3) (p = tab[i = (n - 1) &amp; hash]) == null 判断结点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的结点放入该位置的桶中。
</span><span class=cm>        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置。
</span><span class=cm>    */</span> 
    <span class=k>if</span> <span class=o>((</span><span class=n>p</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>i</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=o>])</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=c1>// 创建一个新的结点存入到桶中
</span><span class=c1></span>        <span class=n>tab</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
    <span class=k>else</span> <span class=o>{</span>
         <span class=c1>// 执行else说明tab[i]不等于null，表示这个位置已经有值了
</span><span class=c1></span>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span> <span class=n>K</span> <span class=n>k</span><span class=o>;</span>
        <span class=cm>/*
</span><span class=cm>        	比较桶中第一个元素(数组中的结点)的hash值和key是否相等
</span><span class=cm>        	1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个hash值是否相等。
</span><span class=cm>                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。
</span><span class=cm>                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
</span><span class=cm>                        return new Node&lt;&gt;(hash, key, value, next);
</span><span class=cm>                    }
</span><span class=cm>                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的。
</span><span class=cm>             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key比较两个key的地址值是否相等。
</span><span class=cm>             3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等。
</span><span class=cm>        */</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>p</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
            <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
                <span class=cm>/*
</span><span class=cm>                	说明：两个元素哈希值相等，并且key的值也相等，将旧的元素整体对象赋值给e，用e来记录
</span><span class=cm>                */</span> 
                <span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
        <span class=c1>// hash值不相等或者key不相等；判断p是否为红黑树结点
</span><span class=c1></span>        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=k>instanceof</span> <span class=n>TreeNode</span><span class=o>)</span>
            <span class=c1>// 放入树中
</span><span class=c1></span>            <span class=n>e</span> <span class=o>=</span> <span class=o>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>p</span><span class=o>).</span><span class=na>putTreeVal</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>tab</span><span class=o>,</span> <span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
        <span class=c1>// 说明是链表结点
</span><span class=c1></span>        <span class=k>else</span> <span class=o>{</span>
            <span class=cm>/*
</span><span class=cm>            	1)如果是链表的话需要遍历到最后结点然后插入
</span><span class=cm>            	2)采用循环遍历的方式，判断链表中是否有重复的key
</span><span class=cm>            */</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>binCount</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=o>;</span> <span class=o>++</span><span class=n>binCount</span><span class=o>)</span> <span class=o>{</span>
                <span class=cm>/*
</span><span class=cm>                	1)e = p.next 获取p的下一个元素赋值给e。
</span><span class=cm>                	2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键，将该键值对插入链表中。
</span><span class=cm>                */</span>
                <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                    <span class=cm>/*
</span><span class=cm>                    	1）创建一个新的结点插入到尾部
</span><span class=cm>                    	 p.next = newNode(hash, key, value, null);
</span><span class=cm>                    	 Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {
</span><span class=cm>                                return new Node&lt;&gt;(hash, key, value, next);
</span><span class=cm>                         }
</span><span class=cm>                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个结点肯定是null。
</span><span class=cm>                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素。
</span><span class=cm>                    */</span>
                    <span class=n>p</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
                    <span class=cm>/*
</span><span class=cm>                    	1)结点添加完成之后判断此时结点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树。
</span><span class=cm>                    	2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历结点的个数。值是0表示第一个结点，1表示第二个结点。。。。7表示第八个结点，加上数组中的的一个元素，元素个数是9。
</span><span class=cm>                    	TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7
</span><span class=cm>                    	如果binCount的值是7(加上数组中的的一个元素，元素个数是9)
</span><span class=cm>                    	TREEIFY_THRESHOLD - 1也是7，此时转换红黑树。
</span><span class=cm>                    */</span>
                    <span class=k>if</span> <span class=o>(</span><span class=n>binCount</span> <span class=o>&gt;=</span> <span class=n>TREEIFY_THRESHOLD</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=c1>// -1 for 1st
</span><span class=c1></span>                        <span class=c1>// 转换为红黑树
</span><span class=c1></span>                        <span class=n>treeifyBin</span><span class=o>(</span><span class=n>tab</span><span class=o>,</span> <span class=n>hash</span><span class=o>);</span>
                    <span class=c1>// 跳出循环
</span><span class=c1></span>                    <span class=k>break</span><span class=o>;</span>
                <span class=o>}</span>
                 
                <span class=cm>/*
</span><span class=cm>                	执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插入的元素的key值是否相等。
</span><span class=cm>                */</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
                    <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
                    <span class=c1>// 相等，跳出循环
</span><span class=c1></span>                    <span class=cm>/*
</span><span class=cm>                		要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了
</span><span class=cm>                		直接执行下面的if语句去替换去 if (e != null) 
</span><span class=cm>                	*/</span>
                    <span class=k>break</span><span class=o>;</span>
                <span class=cm>/*
</span><span class=cm>                	说明新添加的元素和当前结点不相等，继续查找下一个结点。
</span><span class=cm>                	用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
</span><span class=cm>                */</span>
                <span class=n>p</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
        <span class=cm>/*
</span><span class=cm>        	表示在桶中找到key值、hash值与插入元素相等的结点
</span><span class=cm>        	也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值
</span><span class=cm>        	这里完成了put方法的修改功能
</span><span class=cm>        */</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span> 
            <span class=c1>// 记录e的value
</span><span class=c1></span>            <span class=n>V</span> <span class=n>oldValue</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
            <span class=c1>// onlyIfAbsent为false或者旧值为null
</span><span class=c1></span>            <span class=k>if</span> <span class=o>(!</span><span class=n>onlyIfAbsent</span> <span class=o>||</span> <span class=n>oldValue</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                <span class=c1>// 用新值替换旧值
</span><span class=c1></span>                <span class=c1>// e.value 表示旧值  value表示新值 
</span><span class=c1></span>                <span class=n>e</span><span class=o>.</span><span class=na>value</span> <span class=o>=</span> <span class=n>value</span><span class=o>;</span>
            <span class=c1>// 访问后回调
</span><span class=c1></span>            <span class=n>afterNodeAccess</span><span class=o>(</span><span class=n>e</span><span class=o>);</span>
            <span class=c1>// 返回旧值
</span><span class=c1></span>            <span class=k>return</span> <span class=n>oldValue</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=c1>// 修改记录次数
</span><span class=c1></span>    <span class=o>++</span><span class=n>modCount</span><span class=o>;</span>
    <span class=c1>// 判断实际大小是否大于threshold阈值，如果超过则扩容
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(++</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>threshold</span><span class=o>)</span>
        <span class=n>resize</span><span class=o>();</span>
    <span class=c1>// 插入后回调
</span><span class=c1></span>    <span class=n>afterNodeInsertion</span><span class=o>(</span><span class=n>evict</span><span class=o>);</span>
    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
<span class=o>}</span>

</code></pre></div><h6 id=432-将链表转换为红黑树-treeifybin-了解>4.3.2 将链表转换为红黑树 treeifyBin() (了解)<a hidden class=anchor aria-hidden=true href=#432-将链表转换为红黑树-treeifybin-了解>#</a></h6>
<p>结点添加完成之后判断此时结点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=k>if</span> <span class=o>(</span><span class=n>binCount</span> <span class=o>&gt;=</span> <span class=n>TREEIFY_THRESHOLD</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=c1>// -1 for 1st
</span><span class=c1></span>   <span class=c1>//转换为红黑树 tab表示数组名  hash表示哈希值
</span><span class=c1></span>   <span class=n>treeifyBin</span><span class=o>(</span><span class=n>tab</span><span class=o>,</span> <span class=n>hash</span><span class=o>);</span>

</code></pre></div><p>treeifyBin 方法如下所示：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=cm>/*
</span><span class=cm>	替换指定哈希表的索引处桶中的所有链接结点，除非表太小，否则将修改大小。
</span><span class=cm>	Node&lt;K,V&gt;[] tab = tab 数组名
</span><span class=cm>	int hash = hash表示哈希值
</span><span class=cm>*/</span>
<span class=kd>final</span> <span class=kt>void</span> <span class=nf>treeifyBin</span><span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>tab</span><span class=o>,</span> <span class=kt>int</span> <span class=n>hash</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=n>index</span><span class=o>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span>
    <span class=cm>/*
</span><span class=cm>    	如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64)，就去扩容。而不是将结点变为红黑树。
</span><span class=cm>    	目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。
</span><span class=cm>    */</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>tab</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>&lt;</span> <span class=n>MIN_TREEIFY_CAPACITY</span><span class=o>)</span>
        <span class=c1>//扩容方法
</span><span class=c1></span>        <span class=n>resize</span><span class=o>();</span>
    <span class=k>else</span> <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[</span><span class=n>index</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=cm>/*
</span><span class=cm>        	1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化
</span><span class=cm>        	2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e，e是哈希表中指定位置桶里的链表结点，从第一个开始
</span><span class=cm>        */</span>
        <span class=c1>// hd：红黑树的头结点   tl：红黑树的尾结点
</span><span class=c1></span>        <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>hd</span> <span class=o>=</span> <span class=kc>null</span><span class=o>,</span> <span class=n>tl</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
        <span class=k>do</span> <span class=o>{</span>
            <span class=c1>// 新创建一个树的结点，内容和当前链表结点e一致
</span><span class=c1></span>            <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>replacementTreeNode</span><span class=o>(</span><span class=n>e</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>tl</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                <span class=n>hd</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span> <span class=c1>// 将新创键的p结点赋值给红黑树的头结点
</span><span class=c1></span>            <span class=k>else</span> <span class=o>{</span>
                <span class=n>p</span><span class=o>.</span><span class=na>prev</span> <span class=o>=</span> <span class=n>tl</span><span class=o>;</span> <span class=c1>// 将上一个结点p赋值给现在的p的前一个结点
</span><span class=c1></span>                <span class=n>tl</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span> <span class=c1>// 将现在结点p作为树的尾结点的下一个结点
</span><span class=c1></span>            <span class=o>}</span>
            <span class=n>tl</span> <span class=o>=</span> <span class=n>p</span><span class=o>;</span>
            <span class=cm>/*
</span><span class=cm>            	e = e.next 将当前结点的下一个结点赋值给e，如果下一个结点不等于null
</span><span class=cm>            	则回到上面继续取出链表中结点转换为红黑树
</span><span class=cm>            */</span>
        <span class=o>}</span> <span class=k>while</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>);</span>
        <span class=cm>/*
</span><span class=cm>        	让桶中的第一个元素即数组中的元素指向新建的红黑树的结点，以后这个桶里的元素就是红黑树
</span><span class=cm>        	而不是链表数据结构了
</span><span class=cm>        */</span>
        <span class=k>if</span> <span class=o>((</span><span class=n>tab</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=n>hd</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
            <span class=n>hd</span><span class=o>.</span><span class=na>treeify</span><span class=o>(</span><span class=n>tab</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>

</code></pre></div><p>小结：上述操作一共做了如下几件事：</p>
<ol>
<li>根据哈希表中元素个数确定是扩容还是树形化。</li>
<li>如果是树形化遍历桶中的元素，创建相同个数的树形结点，复制内容，建立起联系。</li>
<li>然后让桶中的第一个元素指向新创建的树根结点，替换桶的链表内容为树形化内容。</li>
</ol>
<h6 id=433-扩容方法-resize-重点>4.3.3 扩容方法 resize() (重点)<a hidden class=anchor aria-hidden=true href=#433-扩容方法-resize-重点>#</a></h6>
<p><strong>扩容机制</strong>：</p>
<ol>
<li>
<p>什么时候才需要扩容</p>
<p>当 HashMap 中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor 的默认值是 0.75。</p>
</li>
<li>
<p>HashMap 的扩容是什么</p>
<p><strong>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</strong></p>
<p><strong>设计计算hash值时，要避免出现hash冲突。也就是说不能让它出现链表，更不应该出现红黑树，这样性能很差，如果出现了，证明hash算法，设计的太差。为了避免hash冲突，一，hash算法，二，加载因子。</strong></p>
<p>HashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n - 1) & hash 的结果相比，只是多了一个 bit 位，所以结点要么就在原来的位置，要么就被分配到 <strong>“原位置 + 旧容量”</strong> 这个位置。</p>
<p>例如我们从 16 扩展为 32 时，具体的变化如下所示：</p>
</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=nl>源数组长度:</span>  <span class=n>16</span>   <span class=n>n</span> <span class=o>=</span> <span class=n>16</span>  <span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>=</span><span class=n>15</span>
<span class=o>(</span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span>

					<span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0001</span> <span class=n>0000</span>   <span class=n>16</span>
					<span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>1111</span>   <span class=n>15</span>  <span class=n>n</span><span class=o>-</span><span class=n>1</span>
<span class=nf>假设一个hash1</span><span class=o>(</span><span class=n>key1</span><span class=o>):</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>0000</span> <span class=n>1111</span> <span class=n>0000</span> <span class=n>0101</span>
<span class=o>-----------------------------------------------------------------------------------</span>
				    <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0101</span>   <span class=n>索引</span> <span class=n>5</span>
					
					
					<span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>1111</span>   <span class=n>15</span>  <span class=n>n</span><span class=o>-</span><span class=n>1</span>
<span class=nf>假设一个hash2</span><span class=o>(</span><span class=n>key2</span><span class=o>):</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>0000</span> <span class=n>1111</span> <span class=n>0001</span> <span class=n>0101</span>			
<span class=o>-----------------------------------------------------------------------------------</span>
					<span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0101</span>   <span class=n>索引</span> <span class=n>5</span>

<span class=o>=======================================================================================</span>

<span class=n>此时数组扩容</span><span class=o>--&gt;</span> <span class=n>16</span> <span class=o>*</span> <span class=n>2</span> <span class=o>=</span> <span class=n>32</span>   <span class=n>n</span> <span class=o>=</span> <span class=n>32</span>  <span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>=</span><span class=n>31</span>
<span class=o>(</span><span class=n>n</span><span class=o>-</span><span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span>

					<span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0010</span> <span class=n>0000</span>   <span class=n>32</span>
					<span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0001</span> <span class=n>1111</span>   <span class=n>31</span>  <span class=n>n</span><span class=o>-</span><span class=n>1</span>
<span class=nf>假设一个hash1</span><span class=o>(</span><span class=n>key1</span><span class=o>):</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>0000</span> <span class=n>1111</span> <span class=n>0000</span> <span class=n>0101</span>
<span class=o>-----------------------------------------------------------------------------------</span>
				    <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0101</span>   <span class=n>索引</span> <span class=n>5</span>
					
					<span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0001</span> <span class=n>1111</span>   <span class=n>31</span>  <span class=n>n</span><span class=o>-</span><span class=n>1</span>
<span class=nf>假设一个hash2</span><span class=o>(</span><span class=n>key2</span><span class=o>):</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>1111</span> <span class=n>0000</span> <span class=n>1111</span> <span class=n>0001</span> <span class=n>0101</span>			
<span class=o>-----------------------------------------------------------------------------------</span>
					<span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0000</span> <span class=n>0001</span> <span class=n>0101</span>   <span class=n>索引</span> <span class=n>5</span> <span class=o>+</span> <span class=n>16</span>
					
<span class=n>扩容之后的索引位置要么是原来索引</span><span class=o>,</span><span class=n>要么是原来索引</span> <span class=o>+</span> <span class=n>旧数组容量</span>
<span class=nl>举例:</span>
<span class=n>5</span> <span class=n>或者</span> <span class=n>5</span> <span class=o>+</span> <span class=n>16</span>
					
</code></pre></div><p>因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n - 1 的标记范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化。</p>
<p><img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-1.webp alt>
<strong>说明</strong>：</p>
<p>5 是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以结点要么就在原来的位置，要么就被分配到 <strong>“原位置 + 旧容量”</strong> 这个位置。</p>
<p>因此，我们在扩充 HashMap 的时候，不需要重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就可以了，是 0 的话索引没变，是 1 的话索引变成 <strong>“原位置 + 旧容量”</strong> 。可以看看下图为 16 扩充为 32 的 resize 示意图：</p>
<p><img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-2.webp alt>
正是因为这样巧妙的 rehash 方式，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，在 resize 的过程中保证了 rehash 之后每个桶上的结点数一定小于等于原来桶上的结点数，保证了 rehash 之后不会出现更严重的 hash 冲突，均匀的把之前的冲突的结点分散到新的桶中了。</p>
<p><strong>源码 resize 方法的解读</strong></p>
<p>下面是代码的具体实现：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=nf>resize</span><span class=o>()</span> <span class=o>{</span>
    <span class=c1>// 得到当前数组
</span><span class=c1></span>    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>oldTab</span> <span class=o>=</span> <span class=n>table</span><span class=o>;</span>
    <span class=c1>// 如果当前数组等于null长度返回0，否则返回当前数组的长度
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>oldCap</span> <span class=o>=</span> <span class=o>(</span><span class=n>oldTab</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=n>0</span> <span class=o>:</span> <span class=n>oldTab</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=c1>//当前阀值点 默认是12(16*0.75)
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>oldThr</span> <span class=o>=</span> <span class=n>threshold</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>newCap</span><span class=o>,</span> <span class=n>newThr</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span>
    <span class=c1>// 如果老的数组长度大于0
</span><span class=c1></span>    <span class=c1>// 开始计算扩容后的大小
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>oldCap</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// 超过最大值就不再扩充了，就只好随你碰撞去吧
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>oldCap</span> <span class=o>&gt;=</span> <span class=n>MAXIMUM_CAPACITY</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// 修改阈值为int的最大值
</span><span class=c1></span>            <span class=n>threshold</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>;</span>
            <span class=k>return</span> <span class=n>oldTab</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=cm>/*
</span><span class=cm>        	没超过最大值，就扩充为原来的2倍
</span><span class=cm>        	1) (newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量
</span><span class=cm>        	2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16
</span><span class=cm>        */</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>((</span><span class=n>newCap</span> <span class=o>=</span> <span class=n>oldCap</span> <span class=o>&lt;&lt;</span> <span class=n>1</span><span class=o>)</span> <span class=o>&lt;</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>&amp;&amp;</span>
                 <span class=n>oldCap</span> <span class=o>&gt;=</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=o>)</span>
            <span class=c1>// 阈值扩大一倍
</span><span class=c1></span>            <span class=n>newThr</span> <span class=o>=</span> <span class=n>oldThr</span> <span class=o>&lt;&lt;</span> <span class=n>1</span><span class=o>;</span> <span class=c1>// double threshold
</span><span class=c1></span>    <span class=o>}</span>
    <span class=c1>// 老阈值点大于0 直接赋值
</span><span class=c1></span>    <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>oldThr</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=c1>// 老阈值赋值给新的数组长度
</span><span class=c1></span>        <span class=n>newCap</span> <span class=o>=</span> <span class=n>oldThr</span><span class=o>;</span>
    <span class=k>else</span> <span class=o>{</span> <span class=c1>// 直接使用默认值
</span><span class=c1></span>        <span class=n>newCap</span> <span class=o>=</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=o>;</span><span class=c1>//16
</span><span class=c1></span>        <span class=n>newThr</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span><span class=o>)(</span><span class=n>DEFAULT_LOAD_FACTOR</span> <span class=o>*</span> <span class=n>DEFAULT_INITIAL_CAPACITY</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=c1>// 计算新的resize最大上限
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>newThr</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>float</span> <span class=n>ft</span> <span class=o>=</span> <span class=o>(</span><span class=kt>float</span><span class=o>)</span><span class=n>newCap</span> <span class=o>*</span> <span class=n>loadFactor</span><span class=o>;</span>
        <span class=n>newThr</span> <span class=o>=</span> <span class=o>(</span><span class=n>newCap</span> <span class=o>&lt;</span> <span class=n>MAXIMUM_CAPACITY</span> <span class=o>&amp;&amp;</span> <span class=n>ft</span> <span class=o>&lt;</span> <span class=o>(</span><span class=kt>float</span><span class=o>)</span><span class=n>MAXIMUM_CAPACITY</span> <span class=o>?</span>
                  <span class=o>(</span><span class=kt>int</span><span class=o>)</span><span class=n>ft</span> <span class=o>:</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=c1>// 新的阀值 默认原来是12 乘以2之后变为24
</span><span class=c1></span>    <span class=n>threshold</span> <span class=o>=</span> <span class=n>newThr</span><span class=o>;</span>
    <span class=c1>// 创建新的哈希表
</span><span class=c1></span>    <span class=nd>@SuppressWarnings</span><span class=o>({</span><span class=s>&#34;rawtypes&#34;</span><span class=o>,</span><span class=s>&#34;unchecked&#34;</span><span class=o>})</span>
    <span class=c1>//newCap是新的数组长度--》32
</span><span class=c1></span>    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>newTab</span> <span class=o>=</span> <span class=o>(</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[])</span><span class=k>new</span> <span class=n>Node</span><span class=o>[</span><span class=n>newCap</span><span class=o>];</span>
    <span class=n>table</span> <span class=o>=</span> <span class=n>newTab</span><span class=o>;</span>
    <span class=c1>// 判断旧数组是否等于空
</span><span class=c1></span>    <span class=k>if</span> <span class=o>(</span><span class=n>oldTab</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// 把每个bucket都移动到新的buckets中
</span><span class=c1></span>        <span class=c1>// 遍历旧的哈希表的每个桶，重新计算桶里元素的新位置
</span><span class=c1></span>        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>oldCap</span><span class=o>;</span> <span class=o>++</span><span class=n>j</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span>
            <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>oldTab</span><span class=o>[</span><span class=n>j</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                <span class=c1>// 原来的数据赋值为null 便于GC回收
</span><span class=c1></span>                <span class=n>oldTab</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
                <span class=c1>// 判断数组是否有下一个引用
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                    <span class=c1>// 没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入
</span><span class=c1></span>                    <span class=n>newTab</span><span class=o>[</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>&amp;</span> <span class=o>(</span><span class=n>newCap</span> <span class=o>-</span> <span class=n>1</span><span class=o>)]</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                <span class=c1>//判断是否是红黑树
</span><span class=c1></span>                <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>e</span> <span class=k>instanceof</span> <span class=n>TreeNode</span><span class=o>)</span>
                    <span class=c1>// 说明是红黑树来处理冲突的，则调用相关方法把树分开
</span><span class=c1></span>                    <span class=o>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>e</span><span class=o>).</span><span class=na>split</span><span class=o>(</span><span class=k>this</span><span class=o>,</span> <span class=n>newTab</span><span class=o>,</span> <span class=n>j</span><span class=o>,</span> <span class=n>oldCap</span><span class=o>);</span>
                <span class=k>else</span> <span class=o>{</span> <span class=c1>// 采用链表处理冲突
</span><span class=c1></span>                    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>loHead</span> <span class=o>=</span> <span class=kc>null</span><span class=o>,</span> <span class=n>loTail</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
                    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>hiHead</span> <span class=o>=</span> <span class=kc>null</span><span class=o>,</span> <span class=n>hiTail</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
                    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>next</span><span class=o>;</span>
                    <span class=c1>// 通过上述讲解的原理来计算结点的新位置
</span><span class=c1></span>                    <span class=k>do</span> <span class=o>{</span>
                        <span class=c1>// 原索引
</span><span class=c1></span>                        <span class=n>next</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
                     	<span class=c1>// 这里来判断如果等于true e这个结点在resize之后不需要移动位置
</span><span class=c1></span>                        <span class=k>if</span> <span class=o>((</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>&amp;</span> <span class=n>oldCap</span><span class=o>)</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
                            <span class=k>if</span> <span class=o>(</span><span class=n>loTail</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                                <span class=n>loHead</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                            <span class=k>else</span>
                                <span class=n>loTail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                            <span class=n>loTail</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                        <span class=o>}</span>
                        <span class=c1>// 原索引+oldCap
</span><span class=c1></span>                        <span class=k>else</span> <span class=o>{</span>
                            <span class=k>if</span> <span class=o>(</span><span class=n>hiTail</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                                <span class=n>hiHead</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                            <span class=k>else</span>
                                <span class=n>hiTail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                            <span class=n>hiTail</span> <span class=o>=</span> <span class=n>e</span><span class=o>;</span>
                        <span class=o>}</span>
                    <span class=o>}</span> <span class=k>while</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>next</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>);</span>
                    <span class=c1>// 原索引放到bucket里
</span><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>loTail</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                        <span class=n>loTail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
                        <span class=n>newTab</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>loHead</span><span class=o>;</span>
                    <span class=o>}</span>
                    <span class=c1>// 原索引+oldCap放到bucket里
</span><span class=c1></span>                    <span class=k>if</span> <span class=o>(</span><span class=n>hiTail</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
                        <span class=n>hiTail</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
                        <span class=n>newTab</span><span class=o>[</span><span class=n>j</span> <span class=o>+</span> <span class=n>oldCap</span><span class=o>]</span> <span class=o>=</span> <span class=n>hiHead</span><span class=o>;</span>
                    <span class=o>}</span>
                <span class=o>}</span>
            <span class=o>}</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>newTab</span><span class=o>;</span>
<span class=o>}</span>

</code></pre></div><h6 id=435-查找元素方法-get-重点>4.3.5 查找元素方法 get() (重点)<a hidden class=anchor aria-hidden=true href=#435-查找元素方法-get-重点>#</a></h6>
<p>查找方法，通过元素的 key 找到 value。</p>
<p>代码如下：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=n>V</span> <span class=nf>get</span><span class=o>(</span><span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>;</span>
    <span class=k>return</span> <span class=o>(</span><span class=n>e</span> <span class=o>=</span> <span class=n>getNode</span><span class=o>(</span><span class=n>hash</span><span class=o>(</span><span class=n>key</span><span class=o>),</span> <span class=n>key</span><span class=o>))</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>?</span> <span class=kc>null</span> <span class=o>:</span> <span class=n>e</span><span class=o>.</span><span class=na>value</span><span class=o>;</span>
<span class=o>}</span>

</code></pre></div><p>get 方法主要调用的是 getNode 方法，代码如下：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=kd>final</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>getNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>hash</span><span class=o>,</span> <span class=n>Object</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;[]</span> <span class=n>tab</span><span class=o>;</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>first</span><span class=o>,</span> <span class=n>e</span><span class=o>;</span> <span class=kt>int</span> <span class=n>n</span><span class=o>;</span> <span class=n>K</span> <span class=n>k</span><span class=o>;</span>
    <span class=c1>// 如果哈希表不为空并且key对应的桶上不为空
</span><span class=c1></span>    <span class=k>if</span> <span class=o>((</span><span class=n>tab</span> <span class=o>=</span> <span class=n>table</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>n</span> <span class=o>=</span> <span class=n>tab</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>&gt;</span> <span class=n>0</span> <span class=o>&amp;&amp;</span>
        <span class=o>(</span><span class=n>first</span> <span class=o>=</span> <span class=n>tab</span><span class=o>[(</span><span class=n>n</span> <span class=o>-</span> <span class=n>1</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hash</span><span class=o>])</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=cm>/* 
</span><span class=cm>        	判断数组元素是否相等
</span><span class=cm>        	根据索引的位置检查第一个元素
</span><span class=cm>        	注意：总是检查第一个元素
</span><span class=cm>        */</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>first</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span> <span class=c1>// always check first node
</span><span class=c1></span>            <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>first</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
            <span class=k>return</span> <span class=n>first</span><span class=o>;</span>
        <span class=c1>// 如果不是第一个元素，判断是否有后续结点
</span><span class=c1></span>        <span class=k>if</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>first</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取结点
</span><span class=c1></span>            <span class=k>if</span> <span class=o>(</span><span class=n>first</span> <span class=k>instanceof</span> <span class=n>TreeNode</span><span class=o>)</span>
                <span class=k>return</span> <span class=o>((</span><span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;)</span><span class=n>first</span><span class=o>).</span><span class=na>getTreeNode</span><span class=o>(</span><span class=n>hash</span><span class=o>,</span> <span class=n>key</span><span class=o>);</span>
            <span class=k>do</span> <span class=o>{</span>
                <span class=c1>// 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key
</span><span class=c1></span>                <span class=k>if</span> <span class=o>(</span><span class=n>e</span><span class=o>.</span><span class=na>hash</span> <span class=o>==</span> <span class=n>hash</span> <span class=o>&amp;&amp;</span>
                    <span class=o>((</span><span class=n>k</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>key</span> <span class=o>||</span> <span class=o>(</span><span class=n>key</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>key</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>k</span><span class=o>))))</span>
                    <span class=k>return</span> <span class=n>e</span><span class=o>;</span>
            <span class=o>}</span> <span class=k>while</span> <span class=o>((</span><span class=n>e</span> <span class=o>=</span> <span class=n>e</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
<span class=o>}</span>

</code></pre></div><p>小结：</p>
<ol>
<li>
<p>get 方法实现的步骤：</p>
<p>a. 通过 hash 值获取该 key 映射到的桶
b. 桶上的 key 就是要查找的 key，则直接找到并返回
c. 桶上的 key 不是要找的 key，则查看后续的结点：</p>
<pre tabindex=0><code>	如果后续结点是红黑树结点，通过调用红黑树的方法根据 key 获取 value
	如果后续结点是链表结点，则通过循环遍历链表根据 key 获取 value

</code></pre></li>
<li>
<p>上述红黑树结点调用的是 getTreeNode 方法通过树形结点的 find 方法进行查找：</p>
</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java> <span class=kd>final</span> <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>getTreeNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>h</span><span class=o>,</span> <span class=n>Object</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=o>((</span><span class=n>parent</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=n>root</span><span class=o>()</span> <span class=o>:</span> <span class=k>this</span><span class=o>).</span><span class=na>find</span><span class=o>(</span><span class=n>h</span><span class=o>,</span> <span class=n>k</span><span class=o>,</span> <span class=kc>null</span><span class=o>);</span>
 <span class=o>}</span>
<span class=kd>final</span> <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=nf>find</span><span class=o>(</span><span class=kt>int</span> <span class=n>h</span><span class=o>,</span> <span class=n>Object</span> <span class=n>k</span><span class=o>,</span> <span class=n>Class</span><span class=o>&lt;?&gt;</span> <span class=n>kc</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>p</span> <span class=o>=</span> <span class=k>this</span><span class=o>;</span>
    <span class=k>do</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>ph</span><span class=o>,</span> <span class=n>dir</span><span class=o>;</span> <span class=n>K</span> <span class=n>pk</span><span class=o>;</span>
        <span class=n>TreeNode</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span><span class=n>V</span><span class=o>&gt;</span> <span class=n>pl</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>pr</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>q</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>((</span><span class=n>ph</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>hash</span><span class=o>)</span> <span class=o>&gt;</span> <span class=n>h</span><span class=o>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>pl</span><span class=o>;</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>ph</span> <span class=o>&lt;</span> <span class=n>h</span><span class=o>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>pr</span><span class=o>;</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>((</span><span class=n>pk</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>key</span><span class=o>)</span> <span class=o>==</span> <span class=n>k</span> <span class=o>||</span> <span class=o>(</span><span class=n>k</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>k</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>pk</span><span class=o>)))</span>
            <span class=k>return</span> <span class=n>p</span><span class=o>;</span> <span class=c1>// 找到之后直接返回
</span><span class=c1></span>        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>pl</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>pr</span><span class=o>;</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>pr</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>pl</span><span class=o>;</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>((</span><span class=n>kc</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>||</span>
                  <span class=o>(</span><span class=n>kc</span> <span class=o>=</span> <span class=n>comparableClassFor</span><span class=o>(</span><span class=n>k</span><span class=o>))</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>&amp;&amp;</span>
                 <span class=o>(</span><span class=n>dir</span> <span class=o>=</span> <span class=n>compareComparables</span><span class=o>(</span><span class=n>kc</span><span class=o>,</span> <span class=n>k</span><span class=o>,</span> <span class=n>pk</span><span class=o>))</span> <span class=o>!=</span> <span class=n>0</span><span class=o>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=o>(</span><span class=n>dir</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span> <span class=o>?</span> <span class=n>pl</span> <span class=o>:</span> <span class=n>pr</span><span class=o>;</span>
        <span class=c1>// 递归查找
</span><span class=c1></span>        <span class=k>else</span> <span class=k>if</span> <span class=o>((</span><span class=n>q</span> <span class=o>=</span> <span class=n>pr</span><span class=o>.</span><span class=na>find</span><span class=o>(</span><span class=n>h</span><span class=o>,</span> <span class=n>k</span><span class=o>,</span> <span class=n>kc</span><span class=o>))</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
            <span class=k>return</span> <span class=n>q</span><span class=o>;</span>
        <span class=k>else</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>pl</span><span class=o>;</span>
    <span class=o>}</span> <span class=k>while</span> <span class=o>(</span><span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>);</span>
    <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
<span class=o>}</span>

</code></pre></div><ol>
<li>查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。</li>
<li>这里和插入时一样，如果对比结点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。</li>
<li>若为树，则在树中通过key.equals(k)查找，O(logn)。若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>
</ol>
<h6 id=436-遍历-hashmap-集合几种方式>4.3.6 遍历 HashMap 集合几种方式<a hidden class=anchor aria-hidden=true href=#436-遍历-hashmap-集合几种方式>#</a></h6>
<p>1.分别遍历 Key 和 Values</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=k>for</span> <span class=o>(</span><span class=n>String</span> <span class=n>key</span> <span class=o>:</span> <span class=n>map</span><span class=o>.</span><span class=na>keySet</span><span class=o>())</span> <span class=o>{</span>
	<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
<span class=o>}</span>
<span class=k>for</span> <span class=o>(</span><span class=n>Object</span> <span class=n>vlaue</span> <span class=o>:</span> <span class=n>map</span><span class=o>.</span><span class=na>values</span><span class=o>()</span> <span class=o>{</span>
	<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>value</span><span class=o>);</span>
<span class=o>}</span>

</code></pre></div><p>2.使用 Iterator 迭代器迭代</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=n>Iterator</span><span class=o>&lt;</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Object</span><span class=o>&gt;&gt;</span> <span class=n>iterator</span> <span class=o>=</span> <span class=n>map</span><span class=o>.</span><span class=na>entrySet</span><span class=o>().</span><span class=na>iterator</span><span class=o>();</span>
<span class=k>while</span> <span class=o>(</span><span class=n>iterator</span><span class=o>.</span><span class=na>hasNext</span><span class=o>())</span> <span class=o>{</span>
    <span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Object</span><span class=o>&gt;</span> <span class=n>mapEntry</span> <span class=o>=</span> <span class=n>iterator</span><span class=o>.</span><span class=na>next</span><span class=o>();</span>
    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>mapEntry</span><span class=o>.</span><span class=na>getKey</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;---&#34;</span> <span class=o>+</span> <span class=n>mapEntry</span><span class=o>.</span><span class=na>getValue</span><span class=o>());</span>
<span class=o>}</span>

</code></pre></div><p>3.通过 get 方式（不建议使用）</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=n>Set</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>keySet</span> <span class=o>=</span> <span class=n>map</span><span class=o>.</span><span class=na>keySet</span><span class=o>();</span>
<span class=k>for</span> <span class=o>(</span><span class=n>String</span> <span class=n>str</span> <span class=o>:</span> <span class=n>keySet</span><span class=o>)</span> <span class=o>{</span>
	<span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>str</span> <span class=o>+</span> <span class=s>&#34;---&#34;</span> <span class=o>+</span> <span class=n>map</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>str</span><span class=o>));</span>
<span class=o>}</span>

</code></pre></div><p><strong>说明</strong>：</p>
<p>根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet 获取 Iterator一次，还有通过 get 又迭代一次，降低性能。</p>
<ol>
<li>jdk8 以后使用 Map 接口中的默认方法：</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=k>default</span> <span class=kt>void</span> <span class=nf>forEach</span><span class=o>(</span><span class=n>BiConsumer</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>K</span><span class=o>,?</span> <span class=kd>super</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>action</span><span class=o>)</span> 
<span class=c1>// BiConsumer接口中的方法：
</span><span class=c1></span>	<span class=kt>void</span> <span class=nf>accept</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>,</span> <span class=n>U</span> <span class=n>u</span><span class=o>)</span> <span class=n>对给定的参数执行此操作</span><span class=err>。</span>  
		<span class=n>参数</span> 
            <span class=n>t</span> <span class=o>-</span> <span class=n>第一个输入参数</span> 
            <span class=n>u</span> <span class=o>-</span> <span class=n>第二个输入参数</span> 

</code></pre></div><p>遍历代码：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>map</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>();</span>
<span class=n>map</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;001&#34;</span><span class=o>,</span> <span class=s>&#34;zhangsan&#34;</span><span class=o>);</span>
<span class=n>map</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=s>&#34;002&#34;</span><span class=o>,</span> <span class=s>&#34;lisi&#34;</span><span class=o>);</span>
<span class=n>map</span><span class=o>.</span><span class=na>forEach</span><span class=o>((</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>key</span> <span class=o>+</span> <span class=s>&#34;---&#34;</span> <span class=o>+</span> <span class=n>value</span><span class=o>);</span>
<span class=o>});</span>
</code></pre></div><h3 id=五设计-hashmap-的初始化容量>五、设计 HashMap 的初始化容量<a hidden class=anchor aria-hidden=true href=#五设计-hashmap-的初始化容量>#</a></h3>
<h4 id=51-问题描述>5.1 问题描述<a hidden class=anchor aria-hidden=true href=#51-问题描述>#</a></h4>
<p>如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化 HashMap 的时候就应该指定它的容量，以防止 HashMap 自动扩容，影响使用效率。</p>
<p>默认情况下 HashMap 的容量是 16，但是，如果用户通过构造函数指定了一个数字作为容量，那么 Hash 会选择大于该数字的第一个 2 的幂作为容量（3->4、7->8、9->16）。这点我们在上述已经进行过讲解。</p>
<h4 id=52-阿里巴巴java开发手册的建议>5.2 《阿里巴巴Java开发手册》的建议<a hidden class=anchor aria-hidden=true href=#52-阿里巴巴java开发手册的建议>#</a></h4>
<p>《阿里巴巴Java开发手册》原文：</p>
<p><img loading=lazy src=https://gitee.com/earl9/img/raw/master/img/2021/10105053-3.webp alt>
</p>
<p><strong>关于设置 HashMap 的初始化容量</strong>：</p>
<p>我们上面介绍过，HashMap 的扩容机制，就是当达到扩容条件时会进行扩容。HashMap 的扩容条件就是当 HashMap 中的元素个数（size）超过临界值（threshold）时就会自动扩容。所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap 会有可能发生多次扩容，而 HashMap 中的扩容机制决定了每次扩容都需要重建 hash 表，是非常影响性能的。</p>
<p>但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知 HashMap 中即将存放的 KV 个数的时候，容量设置成多少为好呢？</p>
<p><strong>关于设置 HashMap 的初始化容量大小</strong>：</p>
<p>可以认为，当我们明确知道 HashMap 中元素的个数的时候，把默认容量设置成 <strong>initialCapacity/ 0.75F + 1.0F</strong> 是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p>
<p>而 Jdk 并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个 2 的幂。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://www.wilds.top/tags/java/>Java</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://www.wilds.top/posts/ad0a121e/>
<span class=title>« Prev Page</span>
<br>
<span>ArrayList经典面试题</span>
</a>
<a class=next href=https://www.wilds.top/posts/3af29979/>
<span class=title>Next Page »</span>
<br>
<span>MySQL优化</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://www.wilds.top/>Earlのblog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script src=https://git.wxfljc.cn/Earl/static/raw/branch/master/js/l2dwidget.min.js></script>
<script>var hijiki='/hijiki/assets/hijiki.model.json',config;function show(a){config.model.jsonPath=a,L2Dwidget.init(config)}config={model:{jsonPath:''},display:{superSample:1,width:180,height:290,position:'lift',hOffset:0,vOffset:0},mobile:{show:!0,scale:.75,motion:!0},react:{opacityDefault:1,opacityOnHover:1}},window.onload=function(){show(hijiki)}</script>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>